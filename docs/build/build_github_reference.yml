- id: build_github_reference.overview
  kind: overview
  md: |
    build_github_reference is a helper document containing deterministic conventions and GitHub workflow templates
    used to manage LillyCORE phase/feature cards in the main project board.

    Scope:
    - GitHub project layout (columns/fields) for the main board
    - Command templates for creating/moving/updating cards and appending reports

    Out of scope:
    - Phase planning and decomposition rules (see build_canon and roadmap)
    - Documentation governance and enforcement (see documentation_protocol)
    - QA PASS/FAIL governance (see documentation_protocol.qa_expectations and qa_reference)

    ## 1. GitHub Project Layout Overview

    ### Project Name
    **LillyCORE Main**

    ### Columns
    - **Parking Lot** – Unsorted ideas, future work, or untriaged items.
    - **Backlog** – Planned work not yet ready for execution.
    - **Ready** – Approved cards ready to be executed.
    - **In Progress** – Currently being worked.
    - **Needs Review** – Awaiting QA or Andrew review/sign-off.
    - **Done** – Completed and validated items.
    - **Graveyard** – Archived failed attempts or deprecated work.

    ### Custom Fields
    | Field Name       | Type   | Description |
    |------------------|--------|-------------|
    | Card ID          | Text   | Unique identifier (e.g., `p1.runtime.1`). |
    | Phase ID         | Text   | Phase identifier (e.g., `p1`). |
    | Parent ID        | Text   | Parent card identifier (e.g., `p1` or `p1.runtime`). |
    | Executor Role    | Text   | Role expected to execute (e.g., `architect`, `implementer`, `qa`). |
    | Deliverables     | Text   | Comma-separated deliverables under this card. |
    | Attempt #        | Number | Attempt counter for retries. |

- id: build_github_reference.github_automation_scripts
  kind: reference
  md: |
    ## 2. GitHub Automation Scripts & Command Templates (Main Board)

    Note from Andrew:
      - Card creation automation. Use this script to save a ton of time. 
      ONLY replace the parts listed as replaceable in the templates.
      - Please put the output of this in a temporary canvas. It is a pain to copy any other way
    
    BASIC INSTRUCTIONS (COPY/PASTE FRIENDLY)

    1. Create two scripts from the sections below:

      * template_01_create_issues.sh
      * template_02_set_project_fields.sh

    2. Edit ONLY the “CONFIG YOU MUST SET” sections (top of each script) and the “CARDS TO CREATE” section (bottom of script 01).
      Do not touch the core functions unless you are updating the template itself.

    3. Run in order:
      chmod +x template_01_create_issues.sh template_02_set_project_fields.sh
      ./template_01_create_issues.sh
      ./template_02_set_project_fields.sh

    4. If script 02 warns that items are not found yet, wait ~30–90 seconds and rerun script 02.

    —

    SCRIPT 01 — template_01_create_issues.sh

    #!/usr/bin/env bash
    set -euo pipefail

    # ===============================

    # CONFIG YOU MUST SET (EDIT THIS)

    # ===============================

    OWNER_LOGIN="<OWNER_LOGIN>"                 # e.g. "lillycore-boss" or "YourOrg"
    OWNER_TYPE="user"                           # "user" or "org"
    PROJECT_TITLE="<PROJECT_TITLE>"             # e.g. "LillyCORE Main" (must match UI title)
    WORKDIR="/tmp/lillycore_cards/<phase_id>"   # local temp workspace
    MANIFEST_NAME="manifest.tsv"                # output mapping: card_id -> issue_number -> title

    # Optional: if you want to avoid REUSE behavior, set to 0

    ALLOW_REUSE_BY_TITLE="1"                    # 1 = reuse newest matching exact title, 0 = always create

    # ===============================

    # CORE (DO NOT EDIT)

    # ===============================

    fail(){ echo "ERROR: $*" >&2; exit 1; }
    command -v gh >/dev/null 2>&1 || fail "gh CLI not found"
    command -v jq >/dev/null 2>&1 || fail "jq not found"

    mkdir -p "$WORKDIR"
    MANIFEST="${WORKDIR}/${MANIFEST_NAME}"
    : > "$MANIFEST"

    echo "Writing card bodies under: $WORKDIR"

    author_filter='@me'

    # Deterministic: parse issue number from gh issue create stdout URL.

    # Typical output contains a URL like [https://github.com/](https://github.com/)<owner>/<repo>/issues/<N>

    extract_issue_number_from_create_output() {
    local out="$1"
    echo "$out" 
    | grep -Eo 'https?://[^ ]+/issues/[0-9]+' 
    | tail -n 1 
    | sed -E 's#.*/issues/([0-9]+)$#\1#'
    }

    # Best-effort REUSE lookup by exact title (for cards you already created).

    resolve_issue_number_by_title() {
    local full_title="$1"
    gh issue list --author "$author_filter" --limit 200 
    --json number,title,createdAt 
    --jq "[.[] | select(.title == "$full_title")] | sort_by(.createdAt) | last | .number" 
    | tr -d '\n'
    }

    # Write a body file from stdin (so you can keep card bodies clean and local)

    write_body_file() {
    local path="$1"
    cat > "$path"
    }

    create_or_reuse_issue() {
    local card_id="$1"; shift
    local title_tail="$1"; shift
    local body_file="$1"; shift

    local full_title="${card_id} — ${title_tail}"

    if [[ "$ALLOW_REUSE_BY_TITLE" == "1" ]]; then
    local existing
    existing="$(resolve_issue_number_by_title "$full_title" || true)"
    if [[ -n "$existing" && "$existing" != "null" ]]; then
    printf "%s\t%s\t%s\n" "$card_id" "$existing" "$full_title" >> "$MANIFEST"
    echo "REUSE: $card_id -> #$existing"
    return 0
    fi
    fi

    local create_out
    create_out=$(gh issue create 
    --title "$full_title" 
    --body-file "$body_file" 
    --project "$PROJECT_TITLE")

    local issue_number
    issue_number="$(extract_issue_number_from_create_output "$create_out" || true)"
    if [[ -z "$issue_number" || "$issue_number" == "null" ]]; then
    # fallback (rare)
    issue_number="$(resolve_issue_number_by_title "$full_title" || true)"
    fi

    [[ -n "$issue_number" && "$issue_number" != "null" ]] || fail "Could not resolve issue number for $card_id ($full_title)"

    printf "%s\t%s\t%s\n" "$card_id" "$issue_number" "$full_title" >> "$MANIFEST"
    echo "CREATED: $card_id -> #$issue_number"
    }

    # ===============================

    # CARD BODIES (EDIT THESE)

    # ===============================

    # You can paste full card bodies here. Each card writes to $WORKDIR/<CARD_ID>.md.

    # Keep titles aligned with what script 02 will field-set.

    # --- CARD: P1.1 example ---

    write_body_file "$WORKDIR/P1.1.md" <<'EOF' <PASTE CARD BODY HERE>
    EOF

    # --- CARD: P1.2 example ---

    write_body_file "$WORKDIR/P1.2.md" <<'EOF' <PASTE CARD BODY HERE>
    EOF

    # ===============================

    # CARDS TO CREATE (EDIT THESE)

    # ===============================

    # Format: create_or_reuse_issue "<CARD_ID>" "<TITLE_TAIL>" "$WORKDIR/<CARD_ID>.md"

    create_or_reuse_issue "P1.1" "Runtime Core Loop Owner (Heartbeat + Envelope Integration Plan)" "$WORKDIR/P1.1.md"
    create_or_reuse_issue "P1.2" "Logging + Error Envelope Owner (Spec + Wiring Plan)" "$WORKDIR/P1.2.md"

    # Add more...

    echo
    echo "Manifest written: $MANIFEST"
    cat "$MANIFEST"

    —

    #!/usr/bin/env bash
    set -euo pipefail

    # ===============================
    # CONFIG YOU MUST SET (EDIT THIS)
    # ===============================

    OWNER_LOGIN="<OWNER_LOGIN>"                  # same as script 01
    OWNER_TYPE="user"                            # "user" or "org"
    REPO_NAME="<REPO_NAME>"                      # e.g., "lillycore"
    PROJECT_NUMBER="<PROJECT_NUMBER>"            # numeric project number from the URL (e.g., 6)
    WORKDIR="/tmp/lillycore_cards/<phase_id>"    # must match script 01
    MANIFEST_NAME="manifest.tsv"                 # must match script 01

    # Values you’ll set across cards (edit per phase)
    PHASE_ID="<phase_id>"                        # e.g., "p1"
    PARENT_ID_DEFAULT="<parent_id>"              # e.g., "P1" (Project field value, not issue relationship)
    ATTEMPT_NUMBER="1"

    # Issue-level metadata (repo issue properties)
    MILESTONE_NAME="<milestone_full_name>"       # exact milestone title as shown in GitHub UI
    PARENT_ISSUE_NUMBER_DEFAULT="<parent_issue_number>"  # e.g., "53" (actual GitHub issue number)

    # ===============================
    # CORE (DO NOT EDIT)
    # ===============================

    fail(){ echo "ERROR: $*" >&2; exit 1; }
    warn(){ echo "WARN:  $*" >&2; }

    command -v gh >/dev/null 2>&1 || fail "gh CLI not found"
    command -v jq >/dev/null 2>&1 || fail "jq not found"

    [[ "$OWNER_LOGIN" != "<OWNER_LOGIN>" ]] || fail "Set OWNER_LOGIN"
    [[ "$REPO_NAME" != "<REPO_NAME>" ]] || fail "Set REPO_NAME"
    [[ "$PROJECT_NUMBER" != "<PROJECT_NUMBER>" ]] || fail "Set PROJECT_NUMBER"
    [[ "$PHASE_ID" != "<phase_id>" ]] || fail "Set PHASE_ID"
    [[ "$MILESTONE_NAME" != "<milestone_full_name>" ]] || fail "Set MILESTONE_NAME (full title)"
    [[ "$PARENT_ISSUE_NUMBER_DEFAULT" != "<parent_issue_number>" ]] || fail "Set PARENT_ISSUE_NUMBER_DEFAULT"

    REPO="${OWNER_LOGIN}/${REPO_NAME}"

    MANIFEST="${WORKDIR}/${MANIFEST_NAME}"
    [[ -f "$MANIFEST" ]] || fail "Manifest not found: $MANIFEST (run script 01 first)"

    # ProjectV2 id lookup (user vs org)
    get_project_v2_id() {
      if [[ "$OWNER_TYPE" == "org" ]]; then
        gh api graphql -f query="query { organization(login: \"${OWNER_LOGIN}\") { projectV2(number: ${PROJECT_NUMBER}) { id } } }" \
          --jq '.data.organization.projectV2.id'
      else
        gh api graphql -f query="query { user(login: \"${OWNER_LOGIN}\") { projectV2(number: ${PROJECT_NUMBER}) { id } } }" \
          --jq '.data.user.projectV2.id'
      fi
    }

    PROJECT_V2_ID="$(get_project_v2_id)"
    [[ -n "$PROJECT_V2_ID" && "$PROJECT_V2_ID" != "null" ]] || fail "Could not resolve ProjectV2 ID (check OWNER_LOGIN/TYPE and PROJECT_NUMBER)"

    # Load all project fields once (we need IDs, not names)
    FIELDS_JSON=$(gh api graphql -F projectId="$PROJECT_V2_ID" -f query='
    query($projectId:ID!) {
      node(id:$projectId) {
        ... on ProjectV2 {
          fields(first:100) {
            nodes {
              __typename
              ... on ProjectV2FieldCommon { id name dataType }
              ... on ProjectV2SingleSelectField { id name dataType }
            }
          }
        }
      }
    }')

    field_id_by_name() {
      local name="$1"
      echo "$FIELDS_JSON" | jq -r --arg n "$name" '.data.node.fields.nodes[] | select(.name == $n) | .id' | head -n 1
    }

    # EDIT ONLY IF YOUR FIELD NAMES DIFFER
    FIELD_CARD_ID="$(field_id_by_name "Card ID")"
    FIELD_PHASE_ID="$(field_id_by_name "Phase ID")"
    FIELD_PARENT_ID="$(field_id_by_name "Parent ID")"
    FIELD_EXECUTOR_ROLE="$(field_id_by_name "Executor Role")"
    FIELD_DELIVERABLES="$(field_id_by_name "Deliverables")"
    FIELD_ATTEMPT="$(field_id_by_name "Attempt #")"

    [[ -n "$FIELD_CARD_ID" && "$FIELD_CARD_ID" != "null" ]] || fail "Missing field: Card ID"
    [[ -n "$FIELD_PHASE_ID" && "$FIELD_PHASE_ID" != "null" ]] || fail "Missing field: Phase ID"
    [[ -n "$FIELD_PARENT_ID" && "$FIELD_PARENT_ID" != "null" ]] || fail "Missing field: Parent ID"
    [[ -n "$FIELD_EXECUTOR_ROLE" && "$FIELD_EXECUTOR_ROLE" != "null" ]] || fail "Missing field: Executor Role"
    [[ -n "$FIELD_DELIVERABLES" && "$FIELD_DELIVERABLES" != "null" ]] || fail "Missing field: Deliverables"
    [[ -n "$FIELD_ATTEMPT" && "$FIELD_ATTEMPT" != "null" ]] || fail "Missing field: Attempt #"

    # Project item id lookup by issue number (paged) — FIXED GraphQL literals
    get_item_id_for_issue() {
      local issue_number="$1"
      local cursor="null"

      for _ in $(seq 1 25); do
        local resp
        if [[ "$cursor" == "null" ]]; then
          resp=$(gh api graphql -F projectId="$PROJECT_V2_ID" -f query='
    query($projectId:ID!) {
      node(id:$projectId) {
        ... on ProjectV2 {
          items(first:100) {
            pageInfo { hasNextPage endCursor }
            nodes { id content { ... on Issue { number } } }
          }
        }
      }
    }')
        else
          resp=$(gh api graphql -F projectId="$PROJECT_V2_ID" -F cursor="$cursor" -f query='
    query($projectId:ID!, $cursor:String!) {
      node(id:$projectId) {
        ... on ProjectV2 {
          items(first:100, after:$cursor) {
            pageInfo { hasNextPage endCursor }
            nodes { id content { ... on Issue { number } } }
          }
        }
      }
    }')
        fi

        local found
        found=$(echo "$resp" | jq -r ".data.node.items.nodes[] | select(.content.number == ${issue_number}) | .id" | head -n 1)
        if [[ -n "$found" && "$found" != "null" ]]; then
          echo "$found"
          return 0
        fi

        local has_next
        has_next=$(echo "$resp" | jq -r '.data.node.items.pageInfo.hasNextPage')
        cursor=$(echo "$resp" | jq -r '.data.node.items.pageInfo.endCursor')

        [[ "$has_next" == "true" ]] || break
      done

      return 1
    }

    # Typed field setting
    set_text_field() {
      local item_id="$1"; local field_id="$2"; local value="$3"
      gh project item-edit --id "$item_id" --project-id "$PROJECT_V2_ID" --field-id "$field_id" --text "$value" >/dev/null
    }

    set_number_field() {
      local item_id="$1"; local field_id="$2"; local value="$3"
      gh project item-edit --id "$item_id" --project-id "$PROJECT_V2_ID" --field-id "$field_id" --number "$value" >/dev/null
    }

    # -------------------------------
    # Issue-level metadata setters
    # -------------------------------

    set_issue_milestone() {
      local issue_number="$1"
      if ! gh issue edit "$issue_number" --repo "$REPO" --milestone "$MILESTONE_NAME" >/dev/null 2>&1; then
        warn "Could not set milestone '$MILESTONE_NAME' on ${REPO}#$issue_number (milestone missing or permissions?)"
      fi
    }

    get_issue_node_ids() {
      local parent_num="$1"
      local child_num="$2"
      gh api graphql -f query='
    query($owner:String!, $repo:String!, $parent:Int!, $child:Int!) {
      repository(owner:$owner, name:$repo) {
        parent: issue(number:$parent) { id }
        child:  issue(number:$child)  { id }
      }
    }' -F owner="$OWNER_LOGIN" -F repo="$REPO_NAME" -F parent="$parent_num" -F child="$child_num"
    }

    link_parent_relationship() {
      local parent_num="$1"
      local child_num="$2"

      local ids parent_id child_id
      if ! ids="$(get_issue_node_ids "$parent_num" "$child_num" 2>/dev/null)"; then
        warn "Could not resolve node IDs for parent=${REPO}#$parent_num child=${REPO}#$child_num"
        return 0
      fi

      parent_id="$(echo "$ids" | jq -r '.data.repository.parent.id')"
      child_id="$(echo "$ids" | jq -r '.data.repository.child.id')"

      if [[ -z "$parent_id" || "$parent_id" == "null" || -z "$child_id" || "$child_id" == "null" ]]; then
        warn "Node IDs missing for parent=${REPO}#$parent_num child=${REPO}#$child_num"
        return 0
      fi

      # Link child as sub-issue of parent (fills Relationships → Parent issue)
      if ! gh api graphql -f query='
    mutation($issueId:ID!, $subIssueId:ID!) {
      addSubIssue(input:{issueId:$issueId, subIssueId:$subIssueId}) {
        clientMutationId
      }
    }' -F issueId="$parent_id" -F subIssueId="$child_id" >/dev/null 2>&1; then
        warn "Could not link parent relationship for ${REPO}#$child_num -> parent ${REPO}#$parent_num (feature or perms?)"
      fi
    }

    # ===============================
    # PER-CARD FIELD MAP (EDIT THIS)
    # ===============================

    apply_fields_for_card() {
      local card_id="$1"; local issue_number="$2"; local full_title="$3"

      # Defaults
      local parent_id="$PARENT_ID_DEFAULT"
      local role="implementer"
      local delivers=""
      local parent_issue_number="$PARENT_ISSUE_NUMBER_DEFAULT"

      case "$card_id" in
        P1.1) role="architect"; delivers="P1.D1,P1.D3" ;;
        P1.2) role="architect"; delivers="P1.D2,P1.D3" ;;
        P1.3) role="architect"; delivers="P1.D4" ;;
        P1.4) role="architect"; delivers="P1.D5" ;;
        P1.5) role="architect"; delivers="P1.D6" ;;
        P1.QA) role="qa"; delivers="P1.D1,P1.D2,P1.D3,P1.D4,P1.D5,P1.D6" ;;
        *) warn "No mapping for card_id=$card_id; skipping"; return 0 ;;
      esac

      # Resolve item id (may lag)
      local item_id
      item_id="$(get_item_id_for_issue "$issue_number" || true)"
      if [[ -z "$item_id" || "$item_id" == "null" ]]; then
        warn "Project item not found yet for $card_id (#$issue_number). Rerun in 30–90s."
        return 0
      fi

      # Apply Project fields
      set_text_field "$item_id" "$FIELD_CARD_ID" "$card_id"
      set_text_field "$item_id" "$FIELD_PHASE_ID" "$PHASE_ID"
      set_text_field "$item_id" "$FIELD_PARENT_ID" "$parent_id"
      set_text_field "$item_id" "$FIELD_EXECUTOR_ROLE" "$role"
      set_text_field "$item_id" "$FIELD_DELIVERABLES" "$delivers"
      set_number_field "$item_id" "$FIELD_ATTEMPT" "$ATTEMPT_NUMBER"

      # Apply issue metadata
      set_issue_milestone "$issue_number"
      link_parent_relationship "$parent_issue_number" "$issue_number"

      echo "FIELDS+META SET: $card_id (#$issue_number)"
    }

    # ===============================
    # RUN (DO NOT EDIT)
    # ===============================

    while IFS=$'\t' read -r card_id issue_number full_title; do
      apply_fields_for_card "$card_id" "$issue_number" "$full_title"
    done < "$MANIFEST"

    # Optional:
    # python3 docs/build/registry/registry_sync_from_github.py
    # python3 docs/build/registry/registry_validate.py


    ## 2.05 May still be relevent
    The information below this in 2 was from before the complex scripts above 
    were created and may still be relevent for othere things. 

    Below are standard GitHub CLI command templates for card creation, updating, movement, archiving, and report attachment.

    Notes:
    - These are templates. Replace all `<...>` placeholders.
    - Commands assume issue-based workflow (cards live as GitHub issues).

    ### 2.1 Create a Main Card
    ```bash
    gh issue create \
      --title "<CARD_ID> — <CARD_TITLE>" \
      --body "<card body>" \
      --project "<MAIN_PROJECT_NUMBER>" \
      --field "Card ID=<CARD_ID>" \
      --field "Phase ID=<PHASE_ID>" \
      --field "Parent ID=<PARENT_ID>" \
      --field "Executor Role=<ROLE>" \
      --field "Deliverables=<LIST>" \
      --field "Attempt #=<ATTEMPT_NUMBER>"
    ```

    ### 2.2 Move a Card Between Columns
    ```bash
    gh project item move <ITEM_ID> \
      --project "<MAIN_PROJECT_NUMBER>" \
      --column "<COLUMN_NAME>"
    ```

    Common columns:
    - Parking Lot
    - Backlog
    - Ready
    - In Progress
    - Needs Review
    - Done
    - Graveyard

    ### 2.3 Edit Fields on a Card
    ```bash
    gh project item edit <ITEM_ID> \
      --field "<FIELD_NAME>=<VALUE>"
    ```

    Examples:
    ```bash
    gh project item edit <ITEM_ID> --field "Executor Role=architect"
    gh project item edit <ITEM_ID> --field "Attempt #=2"
    gh project item edit <ITEM_ID> --field "Phase ID=p1"
    ```

    ### 2.4 Append a Report to a Card (Deterministic Append-to-End)
    ```bash
    # Step 1: Retrieve current issue body
    gh issue view <ISSUE_NUMBER> --json body --jq '.body' > card.txt

    # Step 2: Append report
    cat >> card.txt <<'EOF'

    ## Report — <LABEL>
    Timestamp: <TIME>
    --------------------
    <REPORT_CONTENT>

    EOF

    # Step 3: Push updated body
    gh issue edit <ISSUE_NUMBER> --body-file card.txt
    ```

    ### 2.5 Archive a Card (Move to Graveyard)
    ```bash
    gh project item move <ITEM_ID> \
      --project "<MAIN_PROJECT_NUMBER>" \
      --column "Graveyard"
    ```

- id: build_github_reference.notes
  kind: reference
  md: |
    ## 3. Notes & Conventions

    - GPT agents should generate commands, and Andrew manually executes them.
    - Report blocks should be appended to the end of the issue body for deterministic parsing.
    - This document is a build-time tooling reference. It does not define project meaning or QA governance.

- id: build_github_reference.allowed_kinds
  kind: meta
  md: |
    Allowed kinds for BUILD_GITHUB_REFERENCE:

    - overview
    - meta
    - index
    - reference
    - template

    If no existing kind fits a new block, follow
    `documentation_protocol.kind_governance`.

- id: build_github_reference.index
  kind: index
  md: |
    ## BUILD_GITHUB_REFERENCE Block Index

    BUILD_GITHUB_REFERENCE is a helper document containing deterministic conventions and GitHub CLI templates
    used for the LillyCORE Main project board.

    ### Blocks in this file

    - `build_github_reference.overview`
      Overview of the main project board layout (columns/fields) and scope.

    - `build_github_reference.allowed_kinds`
      List of permitted block kinds for this file.

    - `build_github_reference.github_automation_scripts`
      GitHub CLI templates and requirements for creating, moving, editing, archiving, and appending reports to main cards.

    - `build_github_reference.notes`
      Tooling conventions and deterministic append-to-end rule.

    ### Explicitly not defined here

    - Planning/decomposition rules (see build_canon and roadmap)
    - Documentation governance (see documentation_protocol)
    - QA governance (see documentation_protocol and qa_reference)
