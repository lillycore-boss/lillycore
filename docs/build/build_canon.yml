- id: build_canon.overview
  kind: overview
  md: |
    build_canon defines LillyCORE’s **core philosophy, authority model,
    ontology, and planning discipline**.
  
    It is the highest-level source of meaning in the system.
  
    When conflicts arise:
    - Andrew’s explicit instruction always wins.
    - build_canon overrides all other documentation.

- id: build_canon.philosophy_and_authority
  kind: rules
  md: |
    LillyCORE is a modular, evolving AI system.
    Its rules, definitions, and meaning come from Andrew only.

    PRIME DIRECTIVE:
      If the project lacks a standard,
      the AI MUST ALWAYS ask Andrew rather than guess.

    This rule overrides all others — including convenience.

    Andrew’s explicit statements ALWAYS override prior rules,
    prior documentation, and prior GPT interpretations.
    No subsystem, GPT, module, or engine may reinterpret or soften this.

- id: build_canon.global_ai_behaviour_rules
  kind: rules
  md: |
    2.1 — NO ASSUMPTIONS
      - Do NOT invent rules, dependencies, behaviours, limitations,
        or missing pieces of architecture.
      - Do NOT simplify or reinterpret system meaning.
      - When unsure → ASK ANDREW.

    2.2 — ASK BEFORE ACTING
      Any ambiguity → ask Andrew.
      Any missing information → ask Andrew.
      Any unclear dependency → ask Andrew.

    2.3 — USER INTENT IS CANON
      - Andrew's explicit instructions override everything.
      - AI cannot decide something is unnecessary, irrelevant,
        or should be deprioritized unless Andrew says so.
        
    AI MAY NOT:
      - Invent new ontological categories.
      - Reclassify existing engines/plugins without explicit approval.
      
  
- id: build_canon.naming_standards_and_conventions
  kind: rules
  md: |
    - LillyCORE standard for project-owned files and folders is snake_case
      (lowercase_with_underscores).
    - Technical naming details and explicit exceptions (e.g. tool-standard
      filenames and vendored third-party files) are defined in tech_spec
      Section 2, which is the authoritative source for naming rules.
    - Hyphens ("-") in names are only allowed where external tools,
      ecosystems, or third-party artefacts REQUIRE them (e.g.
      .pre-commit-config.yaml, pyproject.toml) or in non-filename titles.
    - Files, folders, modules, and engines MUST follow the folder taxonomy
      defined in the Tools & Environment Spec (tech_spec).

    - Documentation version numbers are optional and symbolic.
      Git is the real version history.
      AI MUST NOT depend on doc version numbers for logic.

- id: build_canon.documentation_standards
  kind: reference
  md: |
    Detailed rules for documentation maintenance, update responsibilities,
    and governance now live in documentation_protocol.
    build_canon no longer defines per-role documentation procedures.

- id: build_canon.planning_and_decomposition
  kind: rules
  md: |
    6.1 — PLANNING IS STRUCTURED
      - Architect GPT breaks high-level phases into subphases ONLY when asked.
      - Architect MUST follow Andrew’s intent.
      - Architect MUST NOT reorder priorities unless Andrew says so.

    6.2 — FEATURE CARDS
      Every feature card MUST follow this structure:

          ### Purpose
          ### Context
          ### Deliverables
          ### Done When
          ### Notes / Future

      Cards MUST be atomic, implementable, and testable.
      Architect MUST NOT:
          - collapse multiple features together
          - create massive monolithic “mega-cards”
          - create ambiguous or self-contradicting cards

    6.3 — PROHIBITED PLANNING BEHAVIOURS
      Architect MUST NOT:
          - assume dependencies
          - invent blockers or limitations
          - delay implementation arbitrarily
          - expand scope without permission
          - reinterpret system meaning
          - drop subsystems from a plan

    6.4 — ACROSS ALL GPTs
      If ANYTHING is unclear:
          YOU MUST ASK ANDREW.
      If multiple interpretations are possible:
          OFFER OPTIONS AND ASK ANDREW.
      If Andrew contradicts documentation:
          ANDREW WINS. Update the docs.

    All LillyCORE features SHOULD use this structure.

    **ID**
    - A short identifier like F-001 or F-002.
    - May match a GitHub Issue or use a separate scheme.
    
    **GPT RULE**
    - Architect MUST use build_canon.feature_card_template. 
    - Implementer MUST NOT alter template semantics.

- id: build_canon.feature_card_template
  kind: template
  md: |
      ID: F-XXX  
      Title: <short feature name>  
      Phase: <roadmap phase numbers>  
      Engine/Plugin: <DRIFT_ENGINE, HELPER_ENGINE, NOTES_PLUGIN, etc.>  
      GitHub: <optional issue link or number>  
      Status: planned | in-progress | implemented | blocked  

      Purpose:
          - Why this feature exists.

      Context:
          - Where it fits in the roadmap or module layout.
          - Relevant background information.

      Deliverables:
          - Concrete outputs (code, behavior, docs).

      Done When:
          - Clear, checkable completion criteria.

      Notes / Future:
          - Follow-ups.
          - Risks or possible extensions.

- id: build_canon.canon_and_roadmap_interaction
  kind: reference
  md: |
    - The Roadmap defines WHEN the system evolves.
    - The Canon defines HOW planning and implementation must behave.

    When a contradiction arises:
      Andrew resolves it.
      Architect then updates docs accordingly.

- id: build_canon.architect_role
  kind: reference
  md: |
    NOTE:
      Detailed procedural rules for the Architect GPT decomposition role,
      including card hierarchies, QA end-caps, and retry counters, have
      been moved to documentation_protocol. This section remains as the
      conceptual anchor that Architect GPT is responsible for decomposition,
      not execution.

- id: build_canon.implementer_role
  kind: reference
  md: |
    NOTE:
      Detailed execution rules for the Implementer GPT, including scope
      boundaries, documentation update duties, and escalation behaviour,
      have been moved to documentation_protocol. build_canon no longer
      carries per-role procedural checklists.

- id: build_canon.qa_role
  kind: reference
  md: |
    NOTE:
      Detailed verification, PASS/FAIL criteria, and correction-card
      workflows for QA GPT have been moved to documentation_protocol.
      build_canon keeps QA only as a conceptual role in the planning
      discipline; the operational protocol is defined elsewhere.

- id: build_canon.updates_to_canon
  kind: rules
  md: |
    - The Canon may ONLY change when Andrew explicitly approves changes.
    - AI MUST NEVER imply or silently modify Canon rules.
    - All Canon changes MUST be committed to Git as visible updates.

    - If an AI believes the Canon requires revision:
          - It MUST NOT change it.
          - It MUST ask Andrew and present the issue clearly.

    - Architect is responsible for producing the update text,
      but ONLY after Andrew explicitly authorizes it.

- id: build_canon.allowed_kinds
  kind: meta
  md: |
    Allowed kinds for BUILD_CANON:

    - overview
    - meta
    - index
    - rules
    - reference
    - template

    If no existing kind fits a new block, follow
    `documentation_protocol.kind_governance`.

- id: build_canon.index
  kind: index
  md: |
    ## BUILD_CANON Block Index

    BUILD_CANON defines LillyCORE’s highest-authority rules:
    philosophy, authority, invariants, and planning discipline.

    It governs **how work must be done**, not how systems are implemented.

    ### Blocks in this file

    - `build_canon.overview`
      High-level purpose and authority statement.

    - `build_canon.philosophy_and_authority`
      Prime directive and Andrew’s authority.

    - `build_canon.global_ai_behaviour_rules`
      Global AI behavior constraints (ask-before-acting, no assumptions).

    - `build_canon.naming_standards_and_conventions`
      Naming and casing rules for project-owned artefacts.

    - `build_canon.documentation_standards`
      Pointer to DOCUMENTATION_PROTOCOL as the procedural authority.

    - `build_canon.planning_and_decomposition`
      Planning rules and decomposition discipline.

    - `build_canon.feature_card_template`
      Canonical template for feature and phase cards.

    - `build_canon.canon_and_roadmap_interaction`
      Relationship between Canon authority and roadmap sequencing.

    - `build_canon.architect_role`
      Conceptual responsibility of the Architect role.

    - `build_canon.implementer_role`
      Conceptual responsibility of the Implementer role.

    - `build_canon.qa_role`
      Conceptual responsibility of the QA role.

    - `build_canon.invariant_no_silent_deferral`
      Invariant #1 — no silent deferrals or hidden stubs.

    - `build_canon.invariant_no_stub_victory`
      Invariant #2 — runtime claims require execution proof.

    - `build_canon.updates_to_canon`
      Rules governing how and when Canon may change.

    ### Explicitly not defined here

    - Repository layout (see TECH_SPEC)
    - Documentation procedures (see DOCUMENTATION_PROTOCOL)
    - Phase sequencing (see ROADMAP)


- id: build_canon.invariant_no_silent_deferral
  kind: rules
  md: |
    ## Invariant: No Silent Deferral (No Hidden Stubs)

    LillyCORE work MUST NOT silently defer, stub, or “leave placeholders” for required behavior.

    ### Definition
    A deferral includes any of the following:
    - Leaving a function/class/module as a stub while claiming the deliverable is complete
    - Returning placeholder values (e.g. `pass`, `TODO`, `return None`) where real behavior is required
    - Skipping integration/wiring work while claiming the system works
    - “We’ll do it later” decisions that are not explicitly tracked

    ### Rule
    If a card’s requirement cannot be implemented *now* (for any reason), the GPT MUST:
    1) STOP and tell Andrew exactly what is being deferred
    2) State the concrete dependency (what must happen first)
    3) Propose the tracking action:
       - add a blocking card/slice, OR
       - mark the current card as blocked

    GPTs MUST NOT:
    - Quietly ship a stub
    - Quietly downgrade a deliverable
    - Quietly reinterpret scope to make a deliverable “go away”

    ### Tracking Requirement
    Any approved deferral MUST be explicitly recorded as one of:
    - a new card/slice with clear DONE WHEN criteria, OR
    - an explicit “BLOCKED BY” note on an existing card that prevents forward phase progression

    If it is not tracked, it is not allowed.

- id: build_canon.invariant_no_stub_victory
  kind: rules
  md: |
    ## Invariant: No Stub Victory (Proof Required for Runtime Claims)

    Any phase/card that introduces or modifies runtime behavior MUST include proof that the behavior executes in the real environment.

    “Runs” or “works” claims without proof are not acceptable.

    ### What requires proof
    Proof is required for any claim that:
    - a runtime loop operates
    - logging emits as specified
    - preferences load/save/override
    - error envelopes are produced/propagated
    - scripts execute successfully
    - CI checks pass
    - any deliverable is “implemented” in a way that depends on execution

    ### Minimum Proof Standard
    For a deliverable to be marked complete, the Implementer MUST provide:
    1) A runnable command (exact invocation)
    2) Raw output artefacts from running it (not paraphrased)
    3) At least one negative-path result when applicable (a controlled failure that proves error handling works)

    “When applicable” means:
    - If the deliverable includes error handling, validation, or envelope behavior,
      a negative-path demonstration is mandatory.
    - If it truly cannot have a negative-path, the Implementer MUST explain why.

    ### QA Enforcement
    QA MUST FAIL any card/phase that claims runtime behavior without:
    - a runnable command, and
    - raw output evidence.

    If proof is missing, the work is incomplete regardless of how correct the code appears.

