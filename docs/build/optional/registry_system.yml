- id: build_registry.overview
  kind: overview
  MD: |
    DESCRIPTION:
    This card defines the Phase Registry System for LillyCORE and the automation scripts
    used to read and update it. It is the canonical reference GPTs and humans should use
    whenever interacting with phase registry files.

    The goal is:
    - A single, predictable way for tools and GPTs to discover phases and subphases.
    - A stable schema for all phase registry files (P0.yml, P1.yml, ..., P11.yml, P8.HD.yml, etc.).
    - A thin layer of scripts that perform safe modifications (add/update slices) without
      hand-editing YAML.

    The registry is **not** a replacement for GitHub cards. It is an index and structural
    map telling the system what phases and slices exist and how they relate.

- id: build_registry.locations
  kind: registry
  MD: |
    ## 1. File Layout

    Unless otherwise specified, all registry files and scripts live under the build/docs
    area of the repository. Example layout:

    ```text
    docs/
      build/
        P0.yml
        P1.yml
        P2.yml
        P3.yml
        P4.yml
        P5.yml
        P6.yml
        P7.yml
        P8.yml
        P8.HD.yml
        P8.DR.yml
        P8.SC.yml
        P9.yml
        P10.yml
        P11.yml

        phase_registry_index.yml

        scripts/
          registry_add_or_update_slice.py
          registry_add_or_update_subslice.py
          registry_validate.py
          registry_mark_phase_state.py
    ```

    GPTs should treat this layout as **canonical** unless the repository explicitly
    documents a different path.

- id: build_registry.file_schema
  kind: schema
  MD: |

    ## 2. Phase Registry File Schema (P0.yml, P1.yml, …)

    Each phase registry file follows the same top-level structure:

    ```yaml
    phase:
      id: P<N>                  # e.g., P0, P1, P2, P8, P8.HD, etc.
      name: "<human-readable phase name>"
      milestone: "<optional milestone label>"
      order: <integer>          # ordering in roadmap (0,1,2,...)

      description: |            # short overview of what this phase does
        ...

      inputs:                   # optional, contextual only
        ...

      deliverables:             # optional detailed deliverable descriptions
        - id: P<N>.D1
          name: "..."
          description: "..."

      constraints:              # optional list of high-level constraints
        - "..."

      structure:
        slices:
          - id: "P0.1"
            title: "Select Technical Baseline Standards (Python Version, Formatter, Linter, Tooling)"
            executor_role: "Architect"
            parent: "P0"
            delivers:
              - "P0.D2"
              - "P0.D6"
            qa_status: "PASS"
            subslices: []       # see next section for nested structure

      qa:
        expectations:
          - "..."
        notes: |
          ...
    ```
    
- id: build_registry.slice_schema
  kind: schema
  MD: |
    ### 2.1 Slice Schema

    Each entry in `structure.slices` (and nested `subslices`) is minimal metadata, not a full card:

    ```yaml
    - id: "P0.1"
      title: "<Card title from GitHub>"
      executor_role: "Architect"   # or "Implementer" / "QA"
      parent: "P0"                 # parent slice or phase id
      delivers:
        - "P0.D2"                  # list of phase-level deliverable ids
        - "P0.D6"
      qa_status: "PASS"            # "PENDING" | "IN_PROGRESS" | "PASS" | "FAIL"
      subslices: []                # nested slice entries (same schema)
    ```

    **Important:**

    * The **full text** of the card (description, steps, DONE_WHEN, QA report, etc.)
      lives in GitHub issues, **not** in the registry.
    * The registry is an **index + topology map**, not a card body store.

- id: build_registry.locations
  kind: registry
  MD: |

    ## 3. Phase Registry Index (phase_registry_index.yml)

    This file is the **master manifest** pointing to all registry files and the scripts
    that operate on them.

    Example skeleton:

    ```yaml
    registry_index:
      version: 1
      root_dir: "."   # base path for phase registry files

      phases:
        - id: "P0"
          name: "Phase 0 — Foundations & Tooling"
          file: "P0.yml"
          kind: "phase"
          state: "active"

        - id: "P1"
          name: "Phase 1 — Core Loop, Logging, User Preferences"
          file: "P1.yml"
          kind: "phase"
          state: "active"

        # ...
        - id: "P8.HD"
          name: "HELP_DESK_ENGINE — Automated Recovery & Error Repair Layer"
          file: "P8.HD.yml"
          kind: "subphase"
          parent: "P8"
          state: "active"

      scripts:
        - name: "registry_add_or_update_slice"
          path: "scripts/registry_add_or_update_slice.py"
          role: "mutation"
          description: "Add or update a slice entry in a phase registry file."

        - name: "registry_add_or_update_subslice"
          path: "scripts/registry_add_or_update_subslice.py"
          role: "mutation"
          description: "Add or update nested subslices (e.g., P0.4.4.1)."

        - name: "registry_validate"
          path: "scripts/registry_validate.py"
          role: "validation"
          description: "Validate all registry files and relationships."

        - name: "registry_mark_phase_state"
          path: "scripts/registry_mark_phase_state.py"
          role: "state-management"
          description: "Mark phases as active/superseded/broken when refactored."
    ```

    GPTs should always go through this index when they need to discover which registry
    files exist and where they live.

    ---

    ## 4. Automation Scripts (for GPT Use)

    GPTs **must not** hand-edit YAML. They should conceptually call these scripts instead
    (and respond with the commands or patch instructions for a human to run).

    ### 4.1 `registry_add_or_update_slice.py`

    **Purpose:**
    Add or update a **top-level slice** (e.g., `P0.2`) in a given phase file (`P0.yml`).

    **Conceptual behaviour:**

    1. Load `<phase>.yml` using a YAML parser.
    2. Locate `phase.structure.slices`.
    3. If a slice with `id == <id>` exists, update its fields.
    4. Otherwise, append a new slice.
    5. Write the file back.

    **Expected slice data:**

    ```yaml
    id: "P0.2"
    title: "Define Documentation Structures and Ingestion Rules"
    executor_role: "Architect"
    parent: "P0"
    delivers: ["P0.D1"]
    qa_status: "PENDING"
    subslices: []
    ```

    ### 4.2 `registry_add_or_update_subslice.py`

    **Purpose:**
    Add or update a **nested subslice** under a parent slice (e.g., `P0.4.4.1` under `P0.4.4`).

    **Conceptual behaviour:**

    1. Load `<phase>.yml`.
    2. Recursively search `structure.slices` and all `subslices` for `parent_id`.
    3. On the matching parent node, access `parent["subslices"]`.
    4. Add/update the child slice (same schema as above).
    5. Write the file back.

    This supports arbitrary depth: `P0.4.4.2.1` is just another subslice under `P0.4.4.2`.

    ### 4.3 `registry_validate.py`

    **Purpose:**
    Sanity-check all registry files listed in `phase_registry_index.yml`.

    Checks might include:

    * YAML parses successfully.
    * `phase.id` matches the registry index `id`.
    * All slice ids are unique within the file.
    * All `parent` references point to valid `phase.id` or slice ids.
    * All `delivers` keys reference valid `phase.deliverables` ids.

    GPTs can suggest adding new validation rules when new invariants appear.

    ### 4.4 `registry_mark_phase_state.py`

    **Purpose:**
    Mark phase or subphase entries in `phase_registry_index.yml` as:

    * `active`
    * `superseded`
    * `deprecated`
    * `broken`

    This is used when:

    * A phase is refactored or replaced.
    * A prototype registry is kept for history but not used.
    * A phase is known bad and should not be trusted by automation.

    ---

    ## 5. GPT Usage Guidelines

    When a GPT needs to **read** registry structure:

    * Prefer reading from:

      * The relevant phase file (`Pn.yml`) **and/or**
      * `phase_registry_index.yml` for global lookups.
    * Do not assume a single flat list of phases; respect nested `subslices`.

    When a GPT needs to **modify** registry structure:

    1. Determine which phase file (`Pn.yml`) must be updated.
    2. Decide whether the target is a **slice** or **subslice**.
    3. Construct the intended slice metadata object:

       * `id`, `title`, `executor_role`, `parent`, `delivers`, `qa_status`, `subslices`.
    4. Propose a call to:

       * `registry_add_or_update_slice.py` for top-level slices, or
       * `registry_add_or_update_subslice.py` for nested elements.

    GPTs should express this as a command or clear pseudo-command for the human or
    automation layer, for example:

    ```text
    Run:
    python docs/build/scripts/registry_add_or_update_slice.py \
      --phase P0.yml \
      --id P0.2 \
      --title "Define Documentation Structures and Ingestion Rules" \
      --executor-role Architect \
      --parent P0 \
      --delivers P0.D1 \
      --qa-status PENDING
    ```

    Or, when nested:

    ```text
    Run:
    python docs/build/scripts/registry_add_or_update_subslice.py \
      --phase P0.yml \
      --parent-id P0.4.4 \
      --id P0.4.4.1 \
      --title "Create and configure QA GitHub Project" \
      --executor-role Implementer \
      --parent P0.4.4 \
      --delivers P0.4.D9 \
      --qa-status PENDING
    ```

    GPTs **must not** manually edit registry YAML and should always anchor their
    edits in this schema and script interface.

    ---

    DONE_WHEN:

    * A single registry reference document exists that:

      * Describes the registry file layout and schemas.
      * Describes the phase registry index and script mapping.
      * Provides clear usage rules for GPTs to read/write registry data safely.
    * Future GPTs can be handed this card and will know:

      * Where phase registry files live.
      * How they are structured.
      * Which scripts they should conceptually invoke to update them.
    * Registry scripts are referenced here and can be implemented or evolved without
      changing the conceptual contract.

    DOCUMENTATION_UPDATES:

    * Canon: Optional note referencing the Phase Registry as part of system governance.
    * TECH_SPEC: Add link/section under “Infrastructure & Tooling” describing registry usage.
    * FEATURES: None (registry is infrastructural).
    * MODULES: None directly, but registry may be referenced by future maintenance engines.
