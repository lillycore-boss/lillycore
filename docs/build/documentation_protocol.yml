- id: documentation_protocol.overview
  kind: overview
  md: |
    # LillyCORE Build Documentation Protocol

    This protocol defines **how build/system documentation is kept in sync with actual behaviour** in LillyCORE
    and how documentation is treated during planning, implementation, and QA.

- id: documentation_protocol.kinds
  kind: meta
  md: |
    Allowed `kind` values for this file:

    - `overview`
    - `spec_section`
    - `meta`
    - `rules`
    - `concept`
    - `reference`
    - `ledger`

    Rules:
    - All blocks in this file MUST use one of these `kind` values.
    - Scripts and GPTs MUST NOT introduce new `kind` values here
      without updating this block.


- id: documentation_protocol.purpose_scope
  kind: spec_section
  md: |
    ## 1. Purpose & Scope

    This protocol defines **how build/system documentation is kept in sync with actual behaviour** in LillyCORE.

    It answers:
    - Which docs must be considered when work is done.
    - Who updates which docs.
    - When GPTs must **stop and ask Andrew** instead of editing docs.
    - How QA treats documentation as part of “Done When”.

    This file is a **procedural overlay** on top of existing rules in:
    - build_canon
    - lillycore_roadmap
    - tech_spec
    - gpt_resource_index
    - feature cards / phase bundles (tracked in GitHub or equivalent)

    Those documents remain authoritative for ontology, technical standards, roadmap, and taxonomy.
    This protocol **does not redefine** any of them; it only describes **how to behave** when updating documentation.

- id: documentation_protocol.relationship
  kind: spec_section
  md: |
    ## 2. Relationship to Other Docs

    This protocol:

    - **Follows**:
      - build_canon §1–§2 (Prime Directive, ask-before-acting, no assumptions).
      - build_canon §4 (documentation standards: every change updates docs; atomic file updates).
      - build_canon role boundaries (Architect, Implementer, QA).

    - **Respects**:
      - tech_spec (repository layout and docs/build location).
      - gpt_resource_index (master directory of canonical docs).
      - feature cards / phase bundles (tracked in GitHub or equivalent).

    When this protocol appears to conflict with any of the above:

    1. **Andrew’s explicit instruction wins.**
    2. Then build_canon, lillycore_roadmap, tech_spec, and gpt_resource_index are updated as needed via approved cards.
    3. This protocol is adjusted afterward to match.

- id: documentation_protocol.responsibilities
  kind: spec_section
  md: |
    ## 3. Roles & Documentation Responsibilities

    This section summarizes **who does what for docs**. It does not change any role definitions from Canon; it just makes them operational for documentation work.

    ### 3.1 Andrew

    - Final authority on:
      - System meaning and ontology (build_canon).
      - Phase sequencing and intentions (lillycore_roadmap).
      - Whether new docs become canonical and are added to gpt_resource_index.
    - Approves:
      - Any change to build_canon or lillycore_roadmap.
      - Any change that alters repository taxonomy (via Architect-designed cards).
      - Any new canonical document type in documentation_governance.

    **Andrew must be asked** explicitly before:

    - Any Canon or Roadmap text is changed.
    - Any new canonical doc type is introduced.
    - Any structural/taxonomy change is made in tech_spec §3.

    ### 3.2 Architect GPT

    - Owns:
      - Updates to gpt_resource_index when new canonical docs are introduced or existing docs change meaning.  
      - System-level conceptual docs (including documentation_governance).

    Architect MUST:

    - Ensure new canonical docs are:
      - Added to gpt_resource_index.
      - Placed in locations allowed by tech_spec and this protocol.
    - Include documentation deliverables in every phase/feature bundle.

    Architect MUST NOT:

    - Invent new doc layers or categories outside documentation_governance.

    ### 3.3 Implementer GPT

    - Is **always responsible** for documentation updates that follow from that card’s changes.

    Implementer MUST:

    - Identify which docs are affected by the work.
    - Update:
      - **feature cards / phase bundles (tracked externally)**: card status, notes, and any mirrored content if the card lives there.  
      - **tech_spec**: when technical standards, tools, or repo layout change as part of the card.  
      - **gpt_resource_index**: *only when* the card explicitly calls for adding or changing indexed docs, and Andrew/Architect have approved.  
      - Other build/system docs (e.g. documentation_protocol, documentation_governance) when the card explicitly includes such changes.

    Implementer MUST:

    - Present doc updates as **ready-to-paste sections**, not fragmented edits.
    - Explicitly state if **no documentation changes are required** and why.

    Implementer MUST NOT:

    - Treat unindexed spec files as canonical.

    When unsure whether a doc should be updated, Implementer MUST:
    - Stop and ask Andrew, or request an Architect clarification card.

    ### 3.4 QA GPT

    - Verifies that **all required documentation updates** have been made for a given card/phase.
    - Uses:
      - feature cards / phase bundles (tracked externally)
      - tech_spec → technical and layout rules
      - gpt_resource_index → canonical doc list
      - documentation_protocol → documentation categories, constraints, and enforcement rules


    QA MUST:

    - Fail any card/phase if doc updates are missing, incomplete, or inconsistent with canonical docs.
    - Generate corrective cards when documentation is wrong or incomplete.
    - Confirm that new canonical docs have been added to gpt_resource_index when required.

    QA MUST NOT:

    - Edit docs directly.

- id: documentation_protocol.update_triggers
  kind: spec_section
  md: |
    ## 4. Update Triggers

    This section lists **when** documentation MUST be considered and potentially updated.  
    “Consider” means **explicitly thinking through whether a given doc is affected**, not blindly editing everything.

    ### 4.1 Code or Behaviour Change (Implementer)

    Whenever code behaviour changes (new function, altered API, changed semantics, removed capability, etc.):

    1. **feature cards / phase bundles (tracked externally)**
        - Update the feature card / phase bundle:
          - Mark status (in-progress → implemented).
          - Note key behavioural changes.
          - Link to any new docs or scripts created by the card (if relevant).

    2. **tech_spec**
        - Consider updates if:
          - Tools or baseline configs change (e.g. new required linter behaviour, new scripts conventions).
          - Repo layout or script expectations change.
          - Typing/linting/test requirements change.

    3. **System-Level Conceptual Docs**
        - Update documentation_protocol or other high-level conceptual docs **only** when the card explicitly includes that as a deliverable.

    ### 4.2 Architecture or Planning Change (Architect)

    When phase structure, ontology, or high-level module responsibilities change:

    1. Update **lillycore_roadmap** (phase sequences, intents).
    2. Update **build_canon** only when ontology / planning discipline changes and Andrew approves.
    4. Update **gpt_resource_index** when the canonical doc set changes.
    5. Update relevant conceptual docs (e.g. documentation_governance) to match the new story.

    All of the above require explicit Architect cards and Andrew’s approval.

    ### 4.3 New Canonical Document Type

    When a new doc is meant to become canonical (e.g. engine spec, plugin spec, DOC schema spec):

    1. Architect designs an appropriate feature/phase card.
    2. Implementer (or Architect, depending on the card) creates the new doc at a location consistent with tech_spec §3 and documentation_governance.
    3. Architect/Implementer:
        - Adds the doc to **gpt_resource_index** with:
          - name  
          - type  
          - status  
          - path  
          - description  
          - usage/access notes
    4. QA verifies that:
        - The new doc is indexed.
        - Its location and category obey tech_spec and documentation_governance.

    Until this flow completes, the doc is treated as **non-authoritative**.

    ### 4.4 Taxonomy / Repo Layout Change

    Any change covered by tech_spec §3’s taxonomy rules (e.g. top-level folder changes, docs layout changes) MUST:

    - Be designed via an Architect card.
    - Update:
      - tech_spec §3 (and related sections).
      - gpt_resource_index if canonical docs move or new top-level doc subtrees are created.
    - Be validated by QA against the new taxonomy.

    Implementers MUST NOT perform these changes under ordinary feature cards.

    ### 4.5 QA-Detected Drift

    When QA detects that runtime behaviour and documentation disagree:

    - QA creates corrective Implementer cards (and a QA card) per the QA System in FEATURES.
    - Implementer:
      - Updates the relevant docs (FEATURES, tech_spec, modules, etc.) to match reality.
      - Ensures changes are consistent with build_canon and lillycore_roadmap.
    - QA re-runs checks for both:
      - The corrective cards.
      - The affected phase bundle.

    If QA determines that docs are wrong because the **behaviour** is wrong, Architect may need to create redesign cards; documentation then follows the corrected design.

- id: documentation_protocol.implementer_flow
  kind: spec_section
  md: |
    ## 5. Standard Implementer Documentation Flow (Per Card)

    For each Implementer leaf card:

    1. **Before coding**
        - Read the card’s Purpose, Context, Deliverables, Done When.
        - Identify **which docs are likely relevant**:
          - FEATURE card/bundle itself.
          - tech_spec (if tools, standards, or layout are affected).
          - modules (if engines/plugins are being realized or re-scoped).
          - Any specific doc mentioned in the card.

    2. **After coding but before declaring “Done”**
        - For each relevant doc, decide:
          - Does the behaviour change require an update?
          - Is the card’s description still accurate?

    3. **Apply updates**
        - Prepare **atomic, ready-to-paste blocks** for each affected doc.
        - For example:
          - An updated module entry in modules.
          - An updated section in tech_spec.
          - An updated card or note in FEATURES or the phase bundle.
        - Do **not** partially patch random lines; replace coherent sections.

    4. **Check canonical alignment**
        - Verify that:
          - No change contradicts build_canon or lillycore_roadmap.
          - Any new or changed responsibilities still respect modules and tech_spec boundaries.
          - You are not accidentally introducing a new canonical doc type without going through gpt_resource_index.

    6. **Report in output**
        - In the Implementer response, clearly list:
          - Which docs you changed (with snippets).
          - Which docs you considered but did not change (with a brief justification).
          - If no docs changed, why that is safe.

- id: documentation_protocol.qa_expectations
  kind: spec_section
  md: |
    ## 7. QA Expectations for Documentation

    QA uses the QA System section in FEATURES as the authoritative operational rulebook.
    This protocol summarizes how QA should apply those rules to documentation.

    For any card/phase to PASS, QA MUST confirm:

    1. **Docs updated where required**
        - FEATURES / phase bundle entries reflect:
          - Completed status.
          - Actual behaviour and deliverables.
        - tech_spec reflects:
          - Any new technical standards, tools, or layout changes.
        - modules reflects:
          - Any changes to engine/plugin status, responsibilities, or dependencies.
        - gpt_resource_index reflects:
          - Any new canonical docs or major changes to existing ones (when the card required it).

    2. **No forbidden docs**
        - No “must-not-have” docs exist (per documentation_protocol), such as:
          - Unindexed spec files that define behaviour
          - Shadow copies of Canon, Tech Spec, or Roadmap with divergent rules
          - Plugin/engine specs that bypass the ontology

    3. **Docs align with Canon and Tech Spec**
        - No doc claims behaviour or layout that violates:
          - build_canon (ontology and AI rules).
          - tech_spec §3 (layout and taxonomy) or other relevant sections.

    4. **All updates are atomic and paste-ready**
        - The Implementer has provided coherent sections rather than ad-hoc line edits.
        - Documentation changes are realistically copy-pastable into the repo.

    If any of these fail, QA MUST:

    - Return **FAIL**.
    - Generate corrective Implementer card(s) and a QA card per the QA System rules.

- id: documentation_protocol.Checklists
  kind: spec_section
  md: |
    ## 8. Quick Checklists

    ### 8.1 Implementer “Before Handing to QA”

    For each leaf card:

    - [ ] I updated or explicitly considered **FEATURES / phase bundle**.  
    - [ ] I checked whether **tech_spec** needs updates (tools, layout, technical rules).  
    - [ ] I checked whether **modules** needs updates (status, responsibilities, dependencies).  
    - [ ] If I created or promoted a doc to canonical, I ensured a plan exists to update **gpt_resource_index**.  
    - [ ] All doc edits are provided as **ready-to-paste blocks**.  

    ### 8.2 Architect “When Designing Cards”

    For each phase or redesign:

    - [ ] I checked build_canon, lillycore_roadmap, tech_spec, FEATURES, gpt_resource_index, and documentation_protocol.
    - [ ] I included **explicit documentation deliverables** for any change that affects behaviour, taxonomy, or canonical docs.  
    - [ ] If new canonical docs are needed, I included tasks to:
      - Create them under allowed locations, and  
      - Add them to gpt_resource_index.  

    ### 8.3 QA “Doc-Focused Sanity Pass”

    For each QA card:

    - [ ] All docs listed in this protocol as relevant to the card/phase have been checked.
    - [ ] No forbidden doc categories are being relied upon (per documentation_protocol).
    - [ ] Any new “important” doc has either been:
      - Explicitly marked non-authoritative, or  
      - Promoted through a card and indexed in gpt_resource_index.  
    - [ ] There is no visible contradiction between Canon, Roadmap, Tech Spec, modules, Features, and the new work.  

- id: documentation_protocol.formatting_replacement
  kind: spec_section
  md: |
    ## 9. Formatting & Replacement Standards

    This section defines how GPTs format **documentation updates** now that
    canonical structure lives in `docs/*.yml` files.

    - The **registry YAML** (IDs, kinds) is the structural authority.
    - The `md` fields inside blocks hold **human-readable markdown only**.
    - We do **not** repeat “FILE: … / ROLE: … / VERSION: …” headers in markdown
      where the same information is already present as YAML metadata.

    These rules apply whenever GPTs are:
    - Proposing changes to registry docs (`docs/registry/*.yml`), or
    - Emitting markdown that will live in `md:` fields inside those registry blocks.

    ### 9.0  Canonical File Block Format

    - id: <required>
    kind: <required>
    md: |
      <required markdown>

    Required blocks per canonical file
    - One overview block (kind: overview)
    - One allowed_kinds block (kind: meta)
    
    ### 9.1 YAML vs Markdown Responsibilities

    YAML defines:
    - Block IDs (`id`)
    - Block kinds (`kind`)

    Markdown (`md:`) defines:
    - The text humans read (explanations, lists, examples, checklists).
    - Local headings inside that block only.

    GPTs MUST NOT:
    - Recreate file-level banners like `FILE: tech_spec`, `ROLE: …`, `VERSION: …`
      inside `md` if that information is already present in YAML metadata.
    - Invent new file-level markers that conflict with the registry format.

    GPTs MAY:
    - Include small inline reminders or labels inside `md` when it helps readability
      (e.g. “This block describes Section 4 – Update Triggers”),
      as long as that does not conflict with the registry metadata.


    ### 9.2 Markdown Style Inside `md` Fields

    When writing markdown inside a block’s `md:`:

    - **Headings**
      - Use normal markdown headings (`#`, `##`, `###`) for structure.
      - Keep heading levels shallow and consistent within a block.
      - Do **not** try to recreate a “top of file” heading; the block itself is
        the unit of meaning.

    - **Lists**
      - Use standard `-` bullet lists or numbered lists.
      - Keep items short and atomic where possible.

    - **Code & Examples**
      - Use fenced code blocks for examples and paste-ready content, e.g.:

        ```markdown
        ```markdown
        ## 4. Update Triggers
        ...
        ```
        ```

      - Choose a language hint (`markdown`, `yaml`, `python`, `text`) when useful.

    - **ASCII SECTION Patterns**
      - Do not use the older `SECTION: ...` ASCII bars.


    ### 9.3 Block-Level Replacement (Not Line-Level Surgery)

    For documentation changes, the **atomic unit of change** is a single registry block:

    - One `blocks[…]` entry with its `id`, `kind`, and `md`.

    GPTs MUST:
    - Replace the entire `md` field for that block when updating it.
    - Avoid “change just these two lines” style instructions.

    In chat, GPTs SHOULD:

    - Present updates as fenced blocks that show the **full new content**:
      - Either the full YAML block, or
      - The full markdown body that should become the new `md:` content.
    - Clearly label what is being replaced, for example:
      - “Replace `documentation_protocol.section.4_update_triggers` md with: …”


    ### 9.4 Markdown Chunks Used in `.md` Files

    When markdown from a registry block is meant to be pasted back into a
    `.md` file (e.g. `docs/build/documentation_protocol.md`):

    - The chunk MUST:
      - Start at a logical heading boundary (e.g. `## 4. Update Triggers`).
      - Include the full section down to (but not including) the next heading
        of the same level, or the end of the parent section.
    - GPTs MUST NOT:
      - Ask for surgical line edits in those files.
      - Depend on fragile alignment or spacing tricks.

- id: documentation_protocol.conflicts_ledger
  kind: ledger
  md: |
    ## Conflict Ledger (Unresolved)

    Purpose:
    - Single place to park conflicting rules/standards so they stop causing drift.

    Format:
    - ID: CL-XXX
      Topic:
      Conflict:
      Temporary rule (until resolved):
      Owner: Andrew
      Status: open | resolved
      Notes:

- id: documentation_protocol.doc_categories
  kind: rules
  md: |
    ## Documentation Categories & Constraints

    This section defines which categories of documentation are permitted to exist
    and how they are treated.

    documentation_protocol is the authoritative source for documentation
    governance, categories, constraints, and enforcement rules.

    Concrete file lists and locations are governed by gpt_resource_index and tech_spec.

    ### Must-Have Categories
    - Core build/system authority docs (e.g. Canon, roadmap, technical specs,
      module boundaries, indexes).
    - Phase or feature bundles that define planned and completed work.

    **Rules**
    - Must-have docs are canonical and authoritative.
    - Any new canonical doc type MUST be indexed in gpt_resource_index and placed
      consistently with tech_spec unless Andrew explicitly overrides.

    ### Should-Have Categories
    - System-level conceptual overviews.
    - Per-plugin conceptual and specification docs.
    - User-facing documentation once user interfaces or APIs exist.
    - Module-level READMEs inside code folders, provided they do not redefine
      canonical behaviour and link back to canonical specs where applicable.

    ### May-Have Categories
    - Exploratory, scratch, or design notes that are clearly marked
      non-authoritative.
    - Generated documentation that is explicitly marked as generated and
      non-authoritative.

    **Rule of Thumb**
    - If a may-have document contradicts a must-have document, the must-have
      document and Andrew’s explicit instructions win.

    ### Must-Not-Have Categories
    - Unindexed documents that define behaviour, rules, or architecture while
      appearing authoritative.
    - Shadow or duplicate copies of canonical docs outside the indexed set.
    - Plugin or engine specs that bypass established ontology.
    - Runtime-generated artefacts treated as specifications.

    **Enforcement**
    - If a must-not-have document appears, it MUST either:
      1) be deleted or clearly marked deprecated, or
      2) be promoted via a feature card and properly indexed (and reflected in
         tech_spec if placement changes are required).

  - id: documentation_protocol.docs_vs_docs_build
    kind: concept
    md: |
      ## docs/ vs docs/build/ (Conceptual Guidance)

      This document clarifies intent (not mechanical migration rules):

      - `docs/`
        - Home for persistent, system-level and shareable documentation (like this file and future high-level narratives)

      - `docs/build/`
        - Home for build/system docs and engineering-time artefacts required to build and maintain LillyCORE

      Any change to physical layout must be designed via Architect cards and reflected in tech_spec and gpt_resource_index.

- id: documentation_protocol.canonical_doc_relationships
  kind: reference
  md: |
    ## Canonical Document Relationships

    - **build_canon**
      Defines ontology, authority, and planning discipline.
      Highest-level meaning; overrides all other docs when conflicts arise.

    - **lillycore_roadmap**
      Defines phase sequencing and intent.

    - **tech_spec**
      Defines technical environment, tooling, and repository layout.

    - **documentation_protocol**
      Defines documentation procedures, update triggers, formatting rules,
      and enforcement expectations. Governs how documentation is created,
      modified, validated, and retired without redefining system ontology.

    - **gpt_resource_index**
      Defines which documents are canonical and where they live.
      A document is not authoritative unless listed here.

    System-level conceptual docs may explain these relationships,
    but MUST NOT redefine ontology, layout, or authority.


- id: documentation_protocol.new_doc_type_criteria
  kind: rules
  md: |
    ## Criteria for Introducing New Canonical Document Types

    A new canonical document type may be introduced ONLY when it:
    - Captures system-level meaning that cannot live in existing canonical docs.
    - Defines persistent concepts (not runtime data or ephemeral artefacts).
    - Supports architectural clarity or cross-role coordination.
    - Is required to describe a new subsystem, contract, or stable interface.

    A document type MUST NOT be introduced merely to store scratch notes,
    partial designs, or exploratory drafts.

    ### Authority & Approval
    - Andrew is the final authority on approving new canonical document types.
    - Architect may propose new types via feature cards.
    - Implementers may create or update such docs only after approval and with
      an explicit card.

    ### Canonical Registration
    - Once approved, a new canonical document type MUST be added to
      gpt_resource_index.
    - A document MUST NOT be treated as canonical unless it appears in
      gpt_resource_index.

    ### Prohibited Document Types
    The following MUST NOT be treated as canonical documents:
    - Runtime logs or error records.
    - Work event histories.
    - Transcripts, summaries, or snapshots generated at runtime.

    ### Lifecycle Expectations
    - Canonical docs are persistent and evolve only via approved feature cards.
    - Each canonical doc MUST have:
      - a clear purpose,
      - a defined owner,
      - explicit relationships to other docs,
      - and a physical location consistent with tech_spec.

- id: documentation_protocol.kind_governance
  kind: rules
  md: |
    ## Governance: Adding or Modifying Block Kinds

    Block kinds are a controlled classification mechanism used to group
    similar blocks by semantic role.

    ### General Rule
    GPTs MUST use an existing kind if one reasonably fits the block’s purpose.

    A new kind may be introduced ONLY if:
    1. No existing kind accurately describes the block’s role
    2. The kind is expected to be reused (not single-use)
    3. The file’s `*.allowed_kinds` block is updated to include it
    4. QA verifies that the new kind is justified and consistently applied

    ### Prohibited Practices
    - Creating a new kind to mirror a block’s topic (e.g. `tooling`, `repo`)
    - Creating role-based or one-off kinds
    - Encoding behaviour or authority into kind names

    ### Authority
    - `kind` is metadata, not identity
    - Block IDs MUST remain stable if a kind changes
    - Final approval of new kinds rests with Andrew

    If unsure whether a new kind is permitted:
    STOP and ask Andrew.
