# docs/registry/tech_spec.yml

version: 1

blocks:
  # --------------------------------
  # Overview / File role
  # --------------------------------
  - id: tech_spec.overview
    kind: overview
    name: tech_spec
    applies_to: [architect, implementer]
    tags: [tech_spec, environment, constraints]
    md: |
      # tech_spec

      **FILE:** tech_spec  
      **ROLE:** Technical standards and environment details for LillyCORE

      > NOTE:
      > - All GPT behavioural, procedural, and documentation-governance rules
      >   have been moved to documentation_protocol and DOCUMENTATION_GOVERNANCE.
      > - This tech_spec now contains only technical constraints, tooling rules,
      >   environment details, naming conventions, and repository structure.

  # --------------------------------
  # Section 1 – Runtimes and Languages
  # --------------------------------
  - id: tech_spec.runtimes_and_languages
    kind: runtimes
    applies_to: [architect, implementer]
    tags: [python, runtimes, typing]
    md: |
      ## SECTION 1: RUNTIMES AND LANGUAGES

      **Primary language:**

      - Python 3.11+ (CPython)

      **Runtime support (Phases 1–3):**

      - Minimum required version: CPython 3.11  
      - Officially supported/tested range: CPython 3.11–3.14 (inclusive)  
      - Recommended development version: CPython 3.13  

      **Notes (Python version rationale, Phases 1–3):**

      - 3.10 is already in security-only support and will reach EOL during the
        Phase 1–3 timeline, so we do NOT target it as a minimum.
      - 3.11–3.14 have long support windows and are fully compatible with modern
        tooling (formatter, linter, test framework).
      - We recommend 3.13 for development to benefit from newer performance
        features while keeping the codebase compatible with 3.11+.

      **Rules:**

      - Always target `python3`, NEVER python2.
      - All runtime code for Phases 1–3 MUST run on CPython 3.11–3.14.
      - Prefer standard library unless a dependency is explicitly approved.

      **Other languages (if any):**

      - (e.g. shell scripts, TypeScript for UI, etc. — leave blank or TODO)

      **TODO:**

      - List any pre-approved third-party libraries once decided.

  # --------------------------------
  # Section 2 – Code Style & Comments
  # --------------------------------
  - id: tech_spec.code_style_and_comments
    kind: style
    applies_to: [architect, implementer]
    tags: [style, formatting, naming]
    md: |
      ## SECTION 2: CODE STYLE & COMMENTS

      **General style:**

      - Follow Pythonic conventions (PEP8-ish, but Andrew is the final authority).

      **Formatter:**

      - LillyCORE USES an auto-formatter for all Python code.
      - Chosen formatter: Black.
      - All Python code committed to the repo MUST be formatted with Black.
      - We use Black's defaults; no custom style overrides beyond its standard behaviour.
      - Effective line length is Black's default (currently 88 characters).

      **Comments:**

      - Use `#` for line comments.
      - For larger logical blocks in config/docs, use this pattern:

        ```text
        # ========================================
        # SECTION: NAME
        # ========================================
        ```

      **Naming conventions:**

      - **Functions and variables:**
        - Use `snake_case` for all Python functions, methods, variables, and module-level names.

      - **Folders and Python modules:**
        - All project-owned folders and Python modules MUST use `snake_case`
          (lowercase_with_underscores).
        - Hyphens (`-`) MUST NOT be used in any importable Python package
          or module name.

      - **Python files:**
        - Python source files MUST use `snake_case` filenames, e.g.:
          - `core_runtime.py`
          - `run_tests.py`
          - `rebuild_notes_index.py`

      - **Non-Python files (project-owned):**
        - Where LillyCORE controls the filename, prefer
          `lowercase_with_underscores`, e.g.:
          - `project_canon.md`
          - `tech_spec.md`
          - `notes_plugin_overview.md`

      - **Allowed exceptions:**
        - Tool- or ecosystem-standard filenames that are defined externally,
          for example (non-exhaustive):
          - `pyproject.toml`
          - `.pre-commit-config.yaml`
          - `.editorconfig`
          - `.gitignore`
          - `.vscode/settings.json`
        - Third-party generated or vendored files that arrive with fixed
          names MUST keep their upstream naming (even if they use hyphens
          or other styles).

      - **Display-only names:**
        - Conceptual document names like PROJECT_CANON, tech_spec, or
          lillycore_roadmap are titles, not filenames; they do not override
          the snake_case rules for actual files in the repo.

      **Per-folder naming expectations (Phase 0 layout):**

      - `core/`:
        - Subfolders and Python modules use `snake_case`, e.g.:
          - `core/runtime/`
          - `core/logging/`
          - `core/ai_pools/`
          - `core/system_doc/`
        - Python files under `core/` use `snake_case`.

      - `engines/`:
        - Each engine lives in a `snake_case` folder:
          - `engines/drift_engine/`
          - `engines/helper_engine/`
          - `engines/plugin_engine/`
          - `engines/helpdesk_engine/`
          - `engines/dream_engine/`
          - `engines/script_engine/`
        - Python modules inside these folders use `snake_case` filenames.

      - `plugins/`:
        - Each plugin lives in a `snake_case` folder:
          - `plugins/notes_plugin/`
          - `plugins/ux_interface/`
          - `plugins/project_management/`
          - `plugins/personal_assistant/`
          - `plugins/multi_user/`
          - `plugins/demos_and_corp/`
        - Python modules inside these folders use `snake_case` filenames.

      - `config/`:
        - Project-owned config files prefer `lowercase_with_underscores`,
          unless an external standard dictates otherwise (e.g. `pyproject.toml`).

      - `scripts/`:
        - All scripts MUST use `snake_case` filenames.

      - `tests/`:
        - Tests mirror the runtime layout and use `snake_case`.

      **Workflow expectations:**

      - Developers SHOULD configure their editor to format-on-save with Black.
      - If format-on-save is not used, developers MUST run Black manually before committing.
      - When git hooks/CI are introduced:
        - A pre-commit hook SHOULD run Black on staged Python files.
        - CI SHOULD include a check that fails if running Black would change the codebase.

      **Linting:**

      - LillyCORE USES a Python linter for all runtime Python code.
      - Chosen linter: Ruff.
      - Ruff is the single source of truth for lint checks.

      **Scope:**

      - All non-generated Python code in the repository is expected to be Ruff-clean.
      - Any exceptions MUST be explicitly excluded in configuration.

      **Strictness philosophy (Phases 0–3):**

      - Enable high-signal rule families (correctness, hygiene, Black-compatible style).
      - Do NOT enforce docstring style, mandatory annotations, complexity metrics in early phases.

      **Enforcement model:**

      - All active Ruff rules become CI errors once CI exists.
      - Developers SHOULD run Ruff locally.

      **Rule configuration:**

      - Ruff configuration MUST live in a central config file.
      - Per-file ignores MUST be justified and narrow.

      **Future tightening:**

      - Additional rule families MAY be enabled later.

      **Typing & type checking:**

      Typing Philosophy (Phases 0–3):

      - LillyCORE uses Python type hints.
      - Hints are encouraged everywhere; enforced for strict modules.

      **Strict Typing Set:**

      - `core/`, `engines/`, and key system modules MUST be fully annotated and mypy-clean.

      **Non-strict modules:**

      - Plugins may run mypy in non-strict mode.

      **Static Type Checker:**

      - LillyCORE uses mypy.
      - mypy configuration MUST live at repo root.

      **Enforcement Model:**

      - Strict modules MUST pass mypy with zero errors.

      **CI Expectations:**

      - CI MUST fail if strict modules fail mypy.

  # --------------------------------
  # Section 3 – Repository Layout
  # --------------------------------
  - id: tech_spec.repo_layout
    kind: repo_layout
    applies_to: [architect, implementer]
    tags: [layout, folders, boundaries]
    md: |
      ## SECTION 3: REPOSITORY LAYOUT

      This section defines the authoritative top-level repository structure
      for LillyCORE in Phase 0.

      ----------------------------------------
      TOP-LEVEL FOLDERS (PHASE 0 STANDARD)
      ----------------------------------------

      - `core/`:
        - Runtime loop
        - Logging
        - Core services
        - AI pools
        - System DOC interfaces

      - `engines/`:
        - All core subsystem engines:
          - DRIFT_ENGINE
          - HELPER_ENGINE
          - PLUGIN_ENGINE
          - HELP_DESK_ENGINE
          - DREAM_ENGINE
          - SCRIPT_ENGINE

      - `plugins/`:
        - All optional add-on subsystems:
          - NOTES_PLUGIN
          - UX_INTERFACE
          - PROJECT_MANAGEMENT
          - PERSONAL_ASSISTANT
          - MULTI_USER
          - DEMOS_AND_CORP

      - `config/`:
        - Central configuration files.

      - `docs/`:
        - Required human-facing documentation.
        - `docs/build/` contains system/build docs:
          - PROJECT_CANON
          - lillycore_roadmap
          - FEATURES
          - tech_spec
          - modules
          - gpt_resource_index

      - `scripts/`:
        - All dev and runtime scripts.

      - `tests/`:
        - pytest-based automated tests.

      ----------------------------------------
      FOLDER RESPONSIBILITIES & BOUNDARIES
      ----------------------------------------

      **Purpose:**
      Tie the top-level folders to the ontology and modules, and define clear boundaries.

      **General dependency rule:**

      - `core/` and `engines/` form the runtime.
      - `plugins/` depends on `core/` and `engines/`, never the reverse.
      - `config/` may be imported by runtime and scripts.
      - `scripts/` may import runtime; runtime MUST NOT import `scripts/`.
      - `tests/` may import anything; runtime MUST NOT import `tests/`.

      (Additional detailed per-folder responsibilities may be expanded here as needed.)

      ----------------------------------------
      MIRRORING RULE
      ----------------------------------------

      All runtime Python code must have a corresponding test root under `tests/`.

      **Examples:**

      - `core/runtime/core_runtime.py` → `tests/core/test_core_runtime.py`
      - `engines/drift_engine/xyz.py` → `tests/core/test_drift_engine_xyz.py`
      - `plugins/notes_plugin/abc.py` → `tests/plugins/test_notes_plugin_abc.py`
      - `scripts/run_tests.py` → `tests/scripts/test_run_tests.py`

      ----------------------------------------
      DOCS LAYOUT RULES (PHASE 0)
      ----------------------------------------

      **Purpose:**
      Ensure build/system docs remain separate from user-facing docs.

      **Build/System docs:**

      - Stored under `docs/build/`.
      - Filenames follow `lowercase_with_underscores`.
      - Conceptual names used only in discussion (PROJECT_CANON, tech_spec).

      **User-facing docs:**

      - Will live under `docs/user/` and `docs/api/` in the future.
      - MUST NOT contain build/system documents.

  # --------------------------------
  # Section 4 – Logging & Error Handling
  # --------------------------------
  - id: tech_spec.logging_and_errors
    kind: logging
    applies_to: [architect, implementer]
    tags: [logging, errors]
    md: |
      ## SECTION 4: LOGGING & ERROR HANDLING

      **Logging:**

      - Unified logging system will be defined in Phase 1.
      - New code SHOULD use it once available.

      **Errors:**

      - Prefer explicit exceptions.
      - Wrap external/IO calls with clear error envelopes.

      **TODO:**

      - Define logging interface once Phase 1 is built.

  # --------------------------------
  # Section 5 – Scripts & CLI Tools
  # --------------------------------
  - id: tech_spec.scripts_and_cli
    kind: scripts
    applies_to: [architect, implementer]
    tags: [scripts, cli, tooling]
    md: |
      ## SECTION 5: SCRIPTS & CLI TOOLS

      This section defines where scripts live, how they are invoked,
      and the CLI norms that all LillyCORE scripts MUST follow.

      **Repository Path Assumptions:**

      - Scripts may import from `core/`, `engines/`, `plugins/`, `config/`.

      ----------------------------------------
      5.1 LOCATION & NAMING
      ----------------------------------------

      **Where scripts live:**

      - All Python scripts live under `scripts/`.

      **File naming:**

      - Script files MUST use `snake_case`.

      **Python only (Phases 0–3):**

      - All official scripts are Python 3.11+.

      ----------------------------------------
      5.2 INVOCATION MODEL
      ----------------------------------------

      **Working directory:**

      - Scripts assume the repository root as working directory.

      **Standard invocation:**

      - `python scripts/<script>.py [ARGS...]`

      **Python module imports:**

      - Scripts SHOULD be importable.
      - SHOULD expose `main(argv) -> int`.

      ----------------------------------------
      5.3 CLI INTERFACE NORMS
      ----------------------------------------

      **Argument parsing:**

      - Use `argparse` or equivalent.

      **Help text:**

      - MUST support `-h` / `--help` with summary and flags.

      **Flag conventions:**

      - Common flags: `--dry-run`, `-v/--verbose`, `-q/--quiet`, `--config PATH`.

      **I/O norms:**

      - `stdout` for normal output; `stderr` for errors.

      ----------------------------------------
      5.4 EXIT CODES
      ----------------------------------------

      All scripts MUST exit with meaningful codes:

      - `0` → success
      - `1` → generic failure
      - `2` → CLI usage error

      Failures MUST print clear messages.

      ----------------------------------------
      5.5 DEVELOPER vs RUNTIME SCRIPTS
      ----------------------------------------

      **Definitions:**

      - Developer scripts:
        - Tools assisting development (Black, Ruff, mypy, pytest).
      - Runtime scripts:
        - Scripts interacting with runtime, engines, DOC.

      **Location:**

      - Both live under `scripts/`.

      **Identification:**

      - Each script MUST declare its type in module docstring.

      ----------------------------------------
      5.6 TESTING SCRIPTS
      ----------------------------------------

      - Tests for scripts live under `tests/scripts/`.
      - Tests SHOULD import the script module and call `main()` where possible.

      ----------------------------------------
      5.7 SUBSTRUCTURE & DENSITY (scripts/)
      ----------------------------------------

      **Default Phase 0 layout:**

      - `scripts/` has no mandatory subfolders.

      **Heuristics for creating subfolders:**

      - Group conceptually related scripts when `scripts/` becomes large.
      - Avoid long-term single-script subfolders.
      - No more than one level of subfolders.

  # --------------------------------
  # Section 6 – Storage & Database
  # --------------------------------
  - id: tech_spec.storage_and_db
    kind: storage
    applies_to: [architect, implementer]
    tags: [storage, db, system_doc]
    md: |
      ## SECTION 6: STORAGE & DATABASE

      **Current state:**

      - System DOC concept defined in Roadmap.
      - No DB engine chosen yet.

      **Interim rules:**

      - For prototypes, prefer file-based or in-memory unless Andrew decides otherwise.

      **TODO:**

      - Choose DB later.
      - Document connection patterns.

  # --------------------------------
  # Section 7 – Environments & Hardware
  # --------------------------------
  - id: tech_spec.environments_and_hardware
    kind: environment
    applies_to: [architect, implementer]
    tags: [env, hardware]
    md: |
      ## SECTION 7: ENVIRONMENTS & HARDWARE

      **Development environment:**

      - Assume local hardware.

      **Hardware constraints:**

      - Do not assume GPU.
      - Do not assume multi-machine cluster.

      **TODO:**

      - Document OS assumptions if they matter.
      - Document appliance constraints in later phases.

  # --------------------------------
  # Section 8 – Testing
  # --------------------------------
  - id: tech_spec.testing
    kind: testing
    applies_to: [architect, implementer]
    tags: [testing, pytest, ci]
    md: |
      ## SECTION 8: TESTING

      **General approach:**

      - Use automated tests where practical.
      - Prefer small, focused tests over monolithic suites.

      **Test framework:**

      - `pytest`.

      **Test folder layout:**

      - `tests/core/`, `tests/plugins/`, `tests/scripts/`.

      **Density heuristics:**

      - Create subfolders when tests grow large or conceptually justify grouping.

      **Running tests:**

      - `pytest` or `python -m pytest` from repo root.

      **CI and static checks:**

      - CI SHOULD run Black, Ruff, mypy (strict modules), pytest.
      - CI SHOULD fail on formatting, lint, typing, or test failures.

  # --------------------------------
  # Section 9 – GPT-specific Notes
  # --------------------------------
  - id: tech_spec.gpt_specific_notes
    kind: gpt_notes
    applies_to: [architect, implementer]
    tags: [gpt, placeholder]
    md: |
      ## SECTION 9: GPT-SPECIFIC NOTES

      > NOTE:
      > - All GPT behavioural, procedural, and documentation-governance rules
      >   have been moved to documentation_protocol and DOCUMENTATION_GOVERNANCE.
      > - This section now exists only as a placeholder for any future
      >   technical GPT-related constraints that may arise.

  # --------------------------------
  # Section 10 – Examples
  # --------------------------------
  - id: tech_spec.examples
    kind: examples
    applies_to: [architect, implementer]
    tags: [examples, typing]
    md: |
      ## SECTION 10: EXAMPLES

      **Example Type Signatures (Python 3.11+)**

      ```python
      from pathlib import Path
      from collections.abc import Sequence
      from typing import Any

      def load_user_preferences(path: Path) -> dict[str, Any]:
          """Load user preferences from disk."""
          ...

      def run_core_loop(config: CoreConfig, *, dry_run: bool = False) -> int:
          """Run the CORE_RUNTIME loop and return an exit code."""
          ...

      def summarize_transcript(
          lines: Sequence[str],
          max_tokens: int | None = None,
      ) -> str:
          """Summarize transcript text for NOTES_PLUGIN."""
          ...
      ```

      **Notes:**

      - Examples illustrate expected annotation style, not behavior.

      ---

      - id: tech.tools.doc_block_tool_cmd
  kind: tool
  applies_to: [architect, implementer, qa, tooling]
  tags: [tools, scripts]
  md: |
    DOC_BLOCK_TOOL_CMD: python scripts/doc_tool.py

