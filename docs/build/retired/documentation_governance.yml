  - id: docs_gov.overview
    kind: overview
    md: |
      # LillyCORE Documentation Governance

      ## Purpose

      This document defines the **conceptual documentation layers and categories** for LillyCORE at the system level.

      It is intentionally **file-path agnostic** where possible: it describes **what kinds of documentation the project should have, who owns them, how they relate to each other, and which are allowed or forbidden**, without redesigning the repository layout. Physical locations and tooling details remain governed by **tech_spec Section 3** and **gpt_resource_index**.

      This file is itself a **system-level conceptual doc**. It exists to:

      - Give humans and GPTs a shared mental model of documentation layers.
      - Clarify which docs are authoritative versus exploratory.
      - Prevent “random spec files” that drift outside gpt_resource_index or conflict with Canon / Tech Spec.

  - id: docs_gov.layers.intro
    kind: concept
    md: |
      ## Doc Layers & Categories

      This section describes **doc layers** conceptually. Individual documents and their physical locations are still indexed and governed by **gpt_resource_index** and **tech_spec**.

      For each layer:

      - **Purpose** – why this category exists.
      - **Audience** – who is expected to read it.
      - **Ownership** – who is responsible for maintaining it.
      - **Lifecycle** – whether it is **build-only** (safe to discard with the repo) or **system-level** (part of LillyCORE’s long-lived meaning).

  - id: docs_gov.layers.build_system_docs
    kind: layer
    md: |
      ### 1. Build / System Docs (Engineering & Control Docs)

      **Examples (non-exhaustive):**
      - PROJECT_CANON
      - LILLYCORE_ROADMAP
      - tech_spec
      - MODULES
      - gpt_resource_index
      - Phase/feature bundles and similar “control plane” docs.

      **Purpose**
      - Define **global rules, technical standards, roadmap, and module boundaries**.
      - Act as the **single source of truth** for how LillyCORE is structured and built.

      **Audience**
      - Andrew (final authority).
      - Architect, Implementer, and QA GPT roles.
      - Human contributors working on the codebase.

      **Ownership**
      - PROJECT_CANON and LILLYCORE_ROADMAP: **Andrew + Architect** (ontology, planning, phase evolution).
      - tech_spec: **Andrew + Architect + Implementers** (technical standards and repo layout).
      - MODULES: **Architect**, with Implementers updating details when modules become real.
      - gpt_resource_index: **Andrew + Architect**, kept in sync whenever new docs become authoritative.

      **Lifecycle**
      - These are **system-level** docs: they define how LillyCORE is meant to behave and evolve.
      - They are **not ephemeral**; they change over time but should never be treated as disposable.
      - Physically, early-phase build/control docs are stored under `docs/build/` as defined in tech_spec; this document does not relocate them.

      **Governance**
      - Must be **indexed in gpt_resource_index** before they are treated as canonical.
      - Must stay consistent with PROJECT_CANON’s ontology and planning rules.
      - **Authoritative specifications** for engines, plugins, DOC layers, and taxonomy belong here or in explicitly related specs, not in ad-hoc files.

      #### Build-Process vs Runtime Build Docs

      Within the Build/System Docs layer, LillyCORE distinguishes between:

      - **Runtime Build Docs**
        - Define the behaviour, architecture, and evolution of the runtime system itself.

      - **Build-Process Docs**
        - Define how humans and GPTs collaborate to build and maintain LillyCORE, without
          becoming part of the runtime system.
        - Examples: GPT_BEHAVIOUR_SPEC, future CONTRIBUTING-style process docs.

      Both categories live under `docs/build/` in early phases, but build-process docs are
      explicitly about the development workflow (e.g. GPT roles, ingestion rules), not runtime
      behaviour. Runtime system specs MUST NEVER rely on build-process docs as behavioural
      authority.

  - id: docs_gov.layers.system_conceptual
    kind: layer
    md: |
      ### 2. System-Level Conceptual Docs

      **Examples (conceptual, not exhaustive):**
      - Documentation governance (this file)
      - High-level architecture overviews and “how LillyCORE fits together” narratives
      - System DOC overviews that explain how System DOC, Plugin DOC, and User DOC relate (without redefining their schemas)

      **Purpose**
      - Provide **narrative explanations** and mental models that bridge core/build docs and everyday work.
      - Explain how the **ontology from PROJECT_CANON** and the **repo layout from tech_spec** map onto concrete workflows and behaviours.

      **Audience**
      - Andrew
      - GPT roles (Architect, Implementer, QA)
      - Human contributors who need an orientation guide

      **Ownership**
      - Primarily **Architect**, with **Implementers** updating descriptions as behaviour becomes real.
      - Andrew has final say on meaning and intent.

      **Lifecycle**
      - **System-level and persistent**: these docs are part of the long-lived understanding of LillyCORE.
      - Expected to live under `docs/` (not `docs/build/`), reflecting their role as shareable, persistent documentation rather than build-only artefacts.
      - Any structural or taxonomic changes that affect physical locations must still be designed and captured in tech_spec and gpt_resource_index via dedicated cards.

      **Governance**
      - Must not contradict PROJECT_CANON, LILLYCORE_ROADMAP, or tech_spec; if conflicts arise, Canon + Andrew’s explicit direction win, and follow-up tasks update these docs.
      - When a conceptual doc becomes authoritative, it should be referenced from gpt_resource_index so GPTs discover it reliably.

  - id: docs_gov.layers.plugin_docs
    kind: layer
    md: |
      ### 3. Plugin-Specific Docs

      **Examples**
      - Conceptual overviews for each plugin (NOTES_PLUGIN, UX_INTERFACE, PROJECT_MANAGEMENT, PERSONAL_ASSISTANT, MULTI_USER, DEMOS_AND_CORP)
      - Per-plugin behaviour descriptions, DOC boundary explanations, and UX narratives

      **Purpose**
      - Describe **what each plugin does**, how it uses core engines and System DOC, and what its Plugin DOC boundaries are.

      **Audience**
      - Plugin authors and maintainers
      - Architect / Implementer GPTs working on that plugin
      - QA GPT verifying plugin behaviour

      **Ownership**
      - Plugin owner (human or engine) for day-to-day updates
      - Architect for structural changes to responsibilities or boundaries (mirrored in MODULES and tech_spec where needed)

      **Lifecycle**
      - System-level for that plugin: persistent as long as the plugin exists
      - Physical location is governed by tech_spec and future cards

      **Governance**
      - Plugin docs may extend but must not redefine System DOC or Plugin DOC ontology.
      - Any plugin that defines new DOC schemas must do so within the Plugin DOC layer and respect the System DOC boundaries in core docs.
      - Authoritative plugin specs should be referenced from gpt_resource_index once they exist, rather than living as unindexed files.

  - id: docs_gov.layers.user_docs
    kind: layer
    md: |
      ### 4. User-Facing Docs (docs/user, docs/api, etc.)

      **Examples (future, per tech_spec):**
      - `docs/user/` – official guides, onboarding, and narratives for human users
      - `docs/api/` – API/SDK documentation exported or generated for external consumers

      **Purpose**
      - Provide clear, stable explanations of how to use LillyCORE and its public surfaces
      - Act as the human-facing contract for behaviour that is stable enough to publish

      **Audience**
      - End users of LillyCORE and its plugins
      - External developers using APIs or SDKs
      - Support / Help Desk flows

      **Ownership**
      - Primarily Andrew + UX / plugin owners, with Architect ensuring alignment to core behaviour
      - Implementer updates are allowed but must not silently change externally observable contracts

      **Lifecycle**
      - System-level and persistent: part of what LillyCORE promises externally
      - Physical location governed by tech_spec and future cards

      **Governance**
      - Must not diverge from the behaviour defined by Canon, Roadmap, Tech Spec, and plugin docs
      - When conflicts arise, user docs are updated to match reality; underlying behaviour changes still go through feature cards and spec updates

  - id: docs_gov.layers.runtime_artefacts
    kind: layer
    md: |
      ### 5. Runtime-Generated Artefacts

      **Examples**
      - Logs and error envelopes
      - Work event records and snapshots
      - Transcripts and summaries stored via System DOC and Notes flows

      **Purpose**
      - Capture what actually happened at runtime: work, state changes, errors, and summaries

      **Audience**
      - Core engines and plugins that read/write System DOC
      - Andrew and maintainers for debugging and audits

      **Ownership**
      - Generated and managed by core runtime, engines, and plugins, not by human editing

      **Lifecycle**
      - Runtime-level, potentially long-lived, but distinct from hand-written docs
      - Stored as data in System DOC and/or plugin DOC, not as markdown spec files

      **Governance**
      - Must not be treated as specification documents
      - Specs may reference runtime artefacts as evidence, but not replace build/system docs

  - id: docs_gov.categories
    kind: rules
    md: |
      ## Doc Categories & Requirements

      This section defines which categories we must have, should have, may have, and must not have. It operates at the conceptual level and relies on gpt_resource_index and tech_spec for concrete file lists and locations.

      ### 1. Must-Have Categories
      - Core Build/System Docs: PROJECT_CANON, LILLYCORE_ROADMAP, tech_spec, MODULES, gpt_resource_index, phase/feature bundles
      - Documentation Governance: this file (or its successor) as the single place describing documentation layers and allowed/forbidden categories

      **Rules**
      - Must be kept in sync with each other whenever code or architecture changes (per Canon rules).
      - Any new canonical doc type must be added to gpt_resource_index and placed consistently with tech_spec unless Andrew overrides.

      ### 2. Should-Have Categories
      - System-level conceptual overviews (architecture, how things fit)
      - Per-plugin conceptual docs (responsibilities, boundaries)
      - User-facing docs once UX/APIs exist
      - Module-level READMEs inside code folders are allowed if they do not redefine canonical behaviour and link back to canonical specs

      ### 3. May-Have Categories
      - Exploratory / scratch / design notes (clearly non-authoritative)
      - Generated documentation (clearly marked generated and non-authoritative)

      Rule of thumb:
      - If a may-have doc contradicts a must-have doc, the must-have doc and Andrew’s explicit instructions win.

      ### 4. Must-Not-Have Categories
      - Unindexed spec files that define behaviour/rules/architecture without being referenced in gpt_resource_index or clearly marked non-authoritative
      - Shadow copies of Canon/Tech Spec/Roadmap outside the canonical doc set
      - Plugin/engine specs that bypass ontology (introduce new meanings without going through Canon)
      - Runtime artefacts treated as specs

      If a must-not-have document appears, it must either:
      1) be deleted or clearly marked deprecated, or
      2) be promoted via a proper feature card plus updates to gpt_resource_index (and tech_spec if needed).


  - id: docs_gov.docs_vs_docs_build
    kind: concept
    md: |
      ## docs/ vs docs/build/ (Conceptual Guidance)

      This document clarifies intent (not mechanical migration rules):

      - `docs/`
        - Home for persistent, system-level and shareable documentation (like this file and future high-level narratives)

      - `docs/build/`
        - Home for build/system docs and engineering-time artefacts required to build and maintain LillyCORE

      Any change to physical layout must be designed via Architect cards and reflected in tech_spec and gpt_resource_index.


  - id: docs_gov.hierarchy_and_roles
    kind: reference
    md: |
      ## Documentation Hierarchy & Canonical Roles

      ### 1. Hierarchy Overview
      LillyCORE documentation is organized into four conceptual layers:
      - Core Build/System Docs
      - System-Level Conceptual Docs
      - Plugin/Engine Docs
      - User-Facing Docs

      All layers inherit constraints from PROJECT_CANON (ontology & rules) and tech_spec (technical standards & layout).

      ### 2. Canonical Document Roles

      **PROJECT_CANON**
      - Defines ontology of engines/plugins/DOC layers; AI behaviour rules and planning discipline
      - Highest-level meaning and constraints
      - Ownership: Andrew + Architect
      - Notes: Overrides all other documents when conflicts arise

      **LILLYCORE_ROADMAP**
      - Defines order and intent of phases
      - Ownership: Andrew + Architect
      - Notes: Must never be changed by Implementers

      **tech_spec**
      - Defines technical environment, coding standards, tools, and repository layout
      - Section 3 is the authoritative declaration of physical file structure
      - Ownership: Andrew + Architect + Implementers

      **MODULES**
      - Defines engines and plugins; boundaries, dependencies, responsibilities
      - Ownership: Architect (Implementers update details as modules become real)

      **FEATURES**
      - Defines feature card format and GitHub integration rules; optionally mirrors selected cards
      - Ownership: Andrew + Architect

      **gpt_resource_index**
      - Master directory of authoritative docs; binds the canonical set
      - Ownership: Andrew + Architect
      - Notes: A doc is not canonical until listed here

      ### 3. Allowed Future Doc Categories (high-level)
      New canonical doc types may be added only via feature cards that update gpt_resource_index (and tech_spec if needed):
      - Engine specs
      - Plugin specs
      - DOC schema specs (System DOC / Plugin DOC)
      - User-facing documentation sets
      - Generated docs (always non-authoritative)

      Any category not listed above is forbidden unless Andrew explicitly authorizes it.

      ### 4. Relationships Between Major Docs
      - PROJECT_CANON → meaning and ontology
      - LILLYCORE_ROADMAP → phase sequencing
      - tech_spec → physical layout & technical rules
      - MODULES → subsystem boundaries
      - FEATURES → task structure and implementation workflow
      - gpt_resource_index → binds all canonical docs together

      System-level conceptual docs (such as this file) interpret and guide; they do not redefine layout or ontology.


  - id: docs_gov.new_doc_types.criteria
    kind: rules
    md: |
      ## Criteria for Introducing New Document Types

      ### 1. Purpose of New Document Types
      New document types should be introduced only when:
      - They capture system-level meaning that cannot live inside existing canonical docs
      - They define persistent concepts, not runtime data or ephemeral structures
      - They support architectural clarity (e.g., a new spec describing a new subsystem)
      - They are needed for cross-role coordination between Architect, Implementer, and QA

      A document type MUST NOT be introduced simply to store scratch notes, partial designs, or exploratory drafts.

      ### 2. Ownership and Authority
      - Andrew is the final authority on whether a new document type is warranted
      - Architect may propose new canonical document types but cannot approve them
      - Implementer may create/update such docs only after approval and with an explicit feature card

      ### 3. Relationship to gpt_resource_index
      Once a new document type becomes canonical:
      - It MUST be added to gpt_resource_index
      - gpt_resource_index becomes the authoritative directory for its meaning, purpose, and physical path
      - GPTs MUST NOT treat a document as canonical unless it appears in gpt_resource_index

      ### 4. Prohibited Document Types
      The following MUST NOT be treated as documents within gpt_resource_index:
      - Runtime logs
      - Work event histories
      - Transcripts or summaries created by System DOC or Notes flows
      - Snapshots or temporary artifacts generated during execution

      ### 5. Lifecycle Expectations
      - Canonical docs are persistent and evolve through approved feature cards
      - Governance docs must remain stable enough for long-term orientation
      - A new canonical doc must have: clear purpose, stable owner, defined relationships, explicit place in repo per tech_spec
