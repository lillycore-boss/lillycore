- id: block_loading.overview
  kind: overview
  md: |
    BLOCK_LOADING defines a procedural system for GPTs working within a large build environment
    where **complete context is never assumed**.

    The system exists to:
    - Minimize initial context load
    - Prevent silent assumptions and hallucinated completeness
    - Make context expansion explicit, auditable, and intentional
    - Enable large systems to be built without monolithic prompts

    GPTs are expected to begin with **insufficient context** and
    actively retrieve what they need using documented mechanisms.

    This document defines:
    - how GPTs request and use blocks
    - how the canvas is used as a working anchor
    - how uncertainty and missing context must be handled

    This document governs **build-time GPT behaviour only**.
    It does not define runtime system behaviour.

- id: block_loading.allowed_kinds
  kind: meta
  md: |
    Allowed kinds for BLOCK_LOADING:

    - overview
    - meta
    - rules
    - process
    - reference
    - template
    - index

    If no existing kind fits a new block,
    follow `documentation_protocol.kind_governance`.

- id: block_loading.operating_principles
  kind: rules
  md: |
    The following principles are mandatory and non-negotiable:

    1. **Incomplete Context Is Expected**
       GPTs MUST assume that important information may be missing.
       Apparent completeness (e.g. indexes, templates, summaries) is NOT proof of authority.

    2. **No Guessing**
       GPTs MUST NOT invent rules, behaviour, structure, schemas, formats,
       governance constraints, lifecycle rules, acceptance criteria, or intent.

    3. **Ask, Don’t Assume**
       When required information is missing or ambiguous:
       - GPTs MUST request the specific governing block IDs needed, OR
       - ask Andrew directly if no governing blocks exist.
       Proceeding without authority is forbidden.

    4. **Explicit Context Expansion**
       GPTs MUST explicitly name the exact block IDs they wish to load.
       Index blocks enable discovery only; they do NOT grant permission to act.

    5. **No Silent Loading**
       GPTs MUST NOT implicitly rely on documents, rules, schemas, formats,
       or governance that have not been explicitly loaded.

    6. **No Unbound Authority References**
       GPTs MUST NOT reference:
       - formats
       - schemas
       - lifecycle rules
       - governance constraints
       - acceptance criteria
       unless the governing block ID defining that authority is:
       - already loaded, AND
       - explicitly cited in the working canvas.

    7. **Exact Authority Usage Only**
       When a governing block is loaded, GPTs MUST:
       - use ONLY the exact terminology, structures, and constraints defined in that block
       - NOT generalise, reinterpret, paraphrase, soften, or “improve” the rules
       - NOT treat situational language (“may”, “should”) as universal unless the block explicitly says so

    8. **No Implicit Authority Substitution**
       Using authoritative-sounding language (e.g. “canonical”, “standard”,
       “per governance”, “expected format”) to stand in for unloaded or undefined
       authority is considered inventing context and is a hard failure.

    9. **No Lookup Deferral**
       GPTs MUST NOT “defer” any action that can be resolved by determining
       whether a governing rule, schema, or process exists.
       If a reference might exist:
       - the GPT MUST discover it via index blocks
       - and MUST load it if found
       Silence or placeholder language is forbidden.

    10. **Andrew Is the Only Source of New Authority**
        If, after index-based discovery, no governing block exists:
        - the GPT MUST stop
        - and MUST ask Andrew before proceeding
        GPTs MUST NOT invent, assume, or extrapolate new governing rules.

    11. **STOP Is a Valid and Required State**
        When required authority is missing, the correct behaviour is to STOP.
        Producing partial, scaffolded, illustrative, or “helpful” output
        in place of authority is a violation of this protocol.

    12. **Confirmation Gate for Large Outputs**
        If the next output is a “large artefact” (e.g., multi-card decompositions,
        full rewrites, bulk templates, multi-step plans), the GPT MUST first present:

        - a short summary of intent, and
        - the proposed artefact outline (headings/IDs only), and
        - an explicit question asking Andrew whether to generate the full body now.

        The GPT MUST NOT emit the full artefact until Andrew explicitly confirms.
        Exceptions are allowed only when Andrew explicitly requests “generate the full output now” in the current turn.

    13. **No Unverified Automation or File/Path Claims**
        The GPT MUST NOT claim that an automation path, script name, workflow, project field, or file location is usable unless:
        - the governing block defining it has been loaded, AND
        - the GPT can point to the exact authority block ID that defines it.
        If a script or automation is merely suggested or “should exist”, the GPT MUST state that it is unverified and MUST ask Andrew before relying on it.
        Any authoritative-sounding substitution is a violation.

- id: block_loading.block_retrieval_flow
  kind: process
  md: |
    When a GPT determines additional context is required:

    1. Identify what information is missing.
    2. Identify the most likely canonical document.
    3. Request one or more specific blocks by ID.
    4. Explain why each block is required.

    Example request:

    - Request `tech_spec.tooling_choices`
      Reason: tooling selection affects implementation decisions.

    - Request `documentation_protocol.update_triggers`
      Reason: documentation impact must be evaluated before completion.

    GPTs MUST NOT request entire documents when a smaller block is sufficient.

- id: block_loading.canvas_usage
  kind: rules
  md: |
    The canvas is a **persistent working surface** used alongside block loading.

    The canvas serves as:
    - a memory anchor
    - a planning surface
    - a progress tracker
    - a place to record loaded context

    GPTs MUST treat the canvas as authoritative for the current task state.

    Loaded blocks, critical rules, and active constraints
    MUST be recorded there for visibility and stability.

- id: block_loading.canvas_template
  kind: template
  md: |
    GPTs SHOULD structure the canvas using the following sections:

    ## Resource Anchors
    - Loaded block IDs
    - Purpose of each loaded block
    - Critical rules or constraints worth keeping visible

    ## Current Card Punchlist (Locked)
    - Deliverables for the active card or phase
    - This section MUST NOT be modified except to check items off
      unless Andrew explicitly authorizes changes
    - One punch item MUST always be documentation

    ## Working Area
    - Notes
    - Draft text
    - Script fragments
    - Output paths
    - Intermediate reasoning

    ## Parking Lot
    - Ideas that are:
      - out of scope
      - future-phase
      - exploratory
      - blocked by missing prerequisites

- id: block_loading.failure_modes
  kind: rules
  md: |
    The following are considered failures:

    - Proceeding with incomplete context without asking
    - Making decisions based on unloaded rules
    - Referencing documents not listed in `gpt_resource_index`
    - Modifying punchlists without authorization
    - Treating missing information as implicit permission

    When a failure condition is encountered,
    GPTs MUST stop and ask Andrew how to proceed.

- id: block_loading.script_interface
  kind: reference
  md: |
    Block retrieval is assisted by a small build script.

    Canonical script:
    - `docs/build/get_md.py`

    Script responsibilities:
    - Return exact block contents (no summarization, no inference)
    - Preserve ordering of requested blocks
    - Perform no reformatting of `md` content

    Primary usage:

    - Fetch one or more blocks (markdown bodies only):
      ```bash
      python3 docs/build/get_md.py --block <block_id_1> <block_id_2> ...
      ```

    - Fetch full YAML blocks (for paste-back into docs):
      ```bash
      python3 docs/build/get_md.py --mode block --block <block_id_1> <block_id_2> ...
      ```

    Standard first pull for any new task:
    - `gpt_resource_index.index`
    - `block_loading.index`
    - (then request specific blocks referenced by those indexes)

- id: block_loading.index
  kind: index
  md: |
    ## BLOCK_LOADING Block Index

    - `block_loading.overview`
      Purpose and scope of the block loading system.

    - `block_loading.allowed_kinds`
      Permitted block kinds for this file.

    - `block_loading.operating_principles`
      Mandatory behavioural rules governing GPT operation.

    - `block_loading.core_rules`
      Alias for `block_loading.operating_principles` (compatibility name).

    - `block_loading.block_retrieval_flow`
      Standard procedure for requesting additional context.

    - `block_loading.canvas_usage`
      Rules governing use of the canvas alongside block loading.

    - `block_loading.canvas_template`
      Canonical canvas structure for GPTs.

    - `block_loading.failure_modes`
      Conditions that require stopping and escalation.

    - `block_loading.script_interface`
      Interface for block retrieval scripts (`docs/build/get_md.py`).

    - `block_loading.default_discovery_set`
      Practical playbook: default blocks to load when a task touches docs/workflows (resource index + block_loading + relevant `*.index`).

    - `block_loading.index`
      This index.

- id: block_loading.core_rules
  kind: reference
  md: |
    ## Compatibility Alias: core_rules

    This block exists for backward compatibility with older prompts/instructions.

    Canonical rules live in:
    - `block_loading.operating_principles`

    GPTs SHOULD load `block_loading.operating_principles` instead of this block.

- id: block_loading.core_rules
  kind: rules
  md: |
    ## Core Rules (Alias)

    This block is an alias for `block_loading.operating_principles`.

    You MUST load block_loading.operating_principles if you requested this one. 

- id: block_loading.default_discovery_set
  kind: reference
  md: |
    ## Default Discovery Set (Practical Playbook)

    When a task references documentation, workflows, or automation,
    GPTs SHOULD begin by loading:

    - `gpt_resource_index.index`
    - `gpt_resource_index.load_paths`
    - `block_loading.index`
    - the relevant document’s `*.index` block

    This is the fastest safe path to situational awareness.
