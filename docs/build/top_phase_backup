üß† GPT Instructions (Do Not Delete)

You are a GPT working with Andrew on the LillyCORE project.

Before generating anything, you MUST:

Ask which role you should assume (Architect or Implementer) if unclear.
Verify role, phase, and current goals with Andrew before beginning.
Follow the project‚Äôs rules as defined in the GPT_RESOURCE_INDEX (provided by Andrew when needed).
NEVER invent system constraints, rules, or interpretations.
ALWAYS ask Andrew when something is unclear or underspecified.
When producing output:

Follow the exact Feature Card structure shown in documentation.
Do NOT add additional sections.
Do NOT omit sections.
Do NOT write real code unless you are the Implementer.
If you need Canon/Roadmap/Feature docs, ask Andrew to paste relevant sections.
DOCUMENT INGESTION RULE Before performing ANY reasoning, drafting, questioning, or planning:

You MUST inspect GPT_RESOURCE_INDEX.

For every document listed in it that is not yet present in this conversation, you MUST say:

‚ÄúPlease provide the full content of <DOC_NAME> so I may load it before continuing.‚Äù

You MUST NOT proceed with any task until all such documents have been provided and you confirm you have read and ingested them.

When starting a new phase or returning after long context loss, you MUST repeat this rule.

---
Current work:
You are required to review `GPT_RESOURCE_INDEX` and any other relevent documents listed therein before begining any work. Andrew will continue to provide relevent parts of it and other supporting documents as needed.


**Phase 0 ‚Äî Foundations & Tooling

Milestone Description**

Purpose

Establish the foundational environment, standards, and documentation structures required for all subsequent phases of LillyCORE. Phase 0 ensures that before any functional architecture or implementation begins, the project has a coherent, stable, and uniform base that GPTs and humans can both operate within reliably.

Scope

Define the documentation structures, formats, and ingestion rules GPTs must follow.

Establish technical standards necessary to begin programming (tooling, Python version, linters/formatters, testing baseline, etc.).

Create or finalize the core repository organization at the conceptual level (folder taxonomy, naming conventions, doc layout).

Define and document the minimal necessary PROJECT_CANON foundations required to begin Phase 1 cleanly.

Establish how standards, docs, and canon will be maintained and updated as the system evolves.

Ensure the project workspace is prepared for consistent execution, even if not all folders or tooling are physically created yet.

System Impact

Introduces the rules that govern all future architecture, implementation, and documentation behaviour.

Establishes the initial documentation and canon anchors that future phases depend upon.

Creates the baseline technical environment which all future code and modules will assume.

Makes the system ‚Äúbootstrapped‚Äù: capable of supporting structured feature cards, milestones, modules, and implementation patterns in later phases.

Inputs Required

Roadmap definitions indicating the role and boundaries of Phase 0.

PROJECT_CANON where it relates to system-wide rules and philosophy (limited to what is required to start development).

Any existing repository or workspace conditions that must be integrated or normalized.

Decisions on tooling requirements (Python version, formatter, linter, testing framework, documentation format rules, etc.).

Documentation format structures needed for GPT comprehension and update consistency.

Outputs Expected

A documented, coherent, and ready-to-use foundational environment that supports beginning Phase 1 development immediately.

A clearly defined and ingestible documentation structure (including rules for updates, organization, and GPT usage).

Initial PROJECT_CANON content sufficient to ground early architectural decisions.

High-level folder taxonomy and repository layout standards.

Tooling and environment standards documented and agreed upon.

A uniform set of foundational constraints that future phases must respect unless explicitly revised.

Constraints

Phase 0 introduces no system functionality beyond documentation, standards, and foundational constructs.

All definitions must remain high-level, avoiding premature architectural or implementation decisions.

No module, engine, or functional code may be designed or implemented beyond establishing the environment in which they will later exist.

All documentation and standards produced must be maintainable by GPTs and must align with PROJECT_CANON and GPT_RESOURCE_INDEX.

Phase 0 outputs must not conflict with later roadmap phases; they serve as prerequisites, not prescriptive architecture.

Notes

Phase 0 is intentionally minimal in system ‚Äúbehavior‚Äù but maximal in importance: all later phases assume its rules and structures exist.

This phase acts as the ‚Äúinitiator card‚Äù for the entire system lifecycle‚Äîevery new phase begins from the standards and canon established here.

Some items may be defined conceptually here but materially created during early implementation phases; Phase 0‚Äôs job is to define them clearly enough for consistent execution.

The focus is clarity, consistency, and readiness: the project must be in a state where GPTs can begin producing Phase 1 artifacts without ambiguity.


=======================================================

üß† GPT Instructions (Do Not Delete)

You are a GPT working with Andrew on the LillyCORE project.

Before generating anything, you MUST:

Ask which role you should assume (Architect or Implementer) if unclear.
Verify role, phase, and current goals with Andrew before beginning.
Follow the project‚Äôs rules as defined in the GPT_RESOURCE_INDEX (provided by Andrew when needed).
NEVER invent system constraints, rules, or interpretations.
ALWAYS ask Andrew when something is unclear or underspecified.
When producing output:

Follow the exact Feature Card structure shown in documentation.
Do NOT add additional sections.
Do NOT omit sections.
Do NOT write real code unless you are the Implementer.
If you need Canon/Roadmap/Feature docs, ask Andrew to paste relevant sections.
DOCUMENT INGESTION RULE Before performing ANY reasoning, drafting, questioning, or planning:

You MUST inspect GPT_RESOURCE_INDEX.

For every document listed in it that is not yet present in this conversation, you MUST say:

‚ÄúPlease provide the full content of <DOC_NAME> so I may load it before continuing.‚Äù

You MUST NOT proceed with any task until all such documents have been provided and you confirm you have read and ingested them.

When starting a new phase or returning after long context loss, you MUST repeat this rule.

Current work: You are required to review GPT_RESOURCE_INDEX and any other relevent documents listed therein before begining any work. Andrew will continue to provide relevent parts of it and other supporting documents as needed.

**Phase 1 ‚Äî Core Loop, Logging, User Preferences

Milestone Description**

Purpose

Establish LillyCORE‚Äôs first functional runtime layer‚Äîintroducing a stable execution heartbeat, unified logging behavior, structured error handling, and the foundational preference system that anchors persistent system identity. Phase 1 transitions LillyCORE from ‚Äúpreparation‚Äù to ‚Äúan application that runs,‚Äù enabling all subsequent phases that rely on a predictable runtime environment.

Scope

Implement a functional core runtime loop capable of continuous operation.

Create unified logging infrastructure that all future modules will depend on.

Define and implement functional error envelopes, including propagation and formatting rules.

Introduce the system-wide preference loader with persistence and override capability.

Establish AI Pool definitions (conceptual and structural only), without execution behavior.

Extend Phase-0 standards where necessary (e.g., documenting runtime contracts, logging rules, and error semantics).

System Impact

First appearance of continuous runtime behavior in the system.

Introduces guaranteed logging pathways that later modules will plug into.

Creates a stable identity layer through persisted system preferences, enabling personalized behavior in future phases.

Establishes the conventions for how errors are wrapped, recorded, and surfaced throughout the entire architecture.

Defines the scaffolding for AI pool organization, allowing Phase 2 to attach functional execution logic.

Ensures all future development assumes a reliable loop, predictable logging, and known preference location/format.

Inputs Required

All foundational structures from Phase 0, including doc formats and technical standards.

Roadmap definition for Phase 1.

Any Canon rules governing runtime behavior, identity persistence, and system integrity (as defined so far).

Directory/folder taxonomy that supports logging, prefs, and runtime configuration.

Decisions on:

preferred persistence mechanism for preferences (file, object, or other)

logging channels (console, file, structured output)

error envelope schema

Outputs Expected

A functioning application runtime loop that can start, run, and stop cleanly.

Unified logging system with documented entry points and formatting rules.

Functional error envelope implementation, integrated into the logging and runtime pathways.

Operational system preference loader with persistence, overrides, and canonical storage format.

AI pool structural definitions (types, fields, relationships) prepared for Phase 2‚Äôs execution engine.

Documentation updated to reflect Phase 1 runtime architecture, logging schema, error semantics, and preference rules.

Constraints

No AI execution, scheduling, or chaining yet‚ÄîAI pools are structural only.

No module-level functionality other than what the runtime, logging, and preferences strictly require.

Must not introduce architectural decisions belonging to Phase 2 (AI execution), Phase 3 (data durability engine), or Phase 4+ subsystems.

All behaviors must align with Phase-0 standards and documentation conventions.

Preference system must be minimal but extensible for future module needs.

Core loop must remain intentionally simple‚Äîno advanced orchestration or plugin behavior yet.

Notes

This is the ‚Äúfirst spark‚Äù of LillyCORE: the transition from a designed system to a running one.

The logging and error envelope structures established here will act as substrate for every future subsystem‚Äôs observability.

Phase-1 preferences lay groundwork for user identity models introduced in later phases.

The AI pool definitions act as placeholders whose semantics become real in Phase 2‚Äôs execution layer.

Clarity and stability matter more than completeness: this runtime must be something all later phases can rely on without surprises.

NOTE: Phase 1 MUST include the first real infrastructure setup

During Phase 0, all decisions (lint tools, formatter, CI expectations, directory conventions, etc.) were chosen but not implemented.
Phase 1 must implement all initial project infrastructure, including:

NOTE DIRECTLY FROM ANDREW: somf of this IS actually set up, but i dont know if any of it is correct, so when making phase 1.1 or whenever this is, ensure we chek if it already exsists, if it does make sure it is configured properly (if not fix it) and if it dosn't exsist create it, install it, configuyre it, wahatever. END OF ANDREW NOTE

Repository Initialization

Create the actual Git repository containing the project files.

Establish the initial folder layout as defined in TECH_SPEC.

Add Configuration Files

pyproject.toml (Black, Ruff, version metadata).

Any initial project metadata files required by the spec.

Set Up CI

Configure GitHub Actions (or chosen CI) to run:

Black formatting check.

Ruff lint check.

Test suite once available.

CI must fail on:

Black reformatting needed.

Ruff lint errors.

Test failures.

Install Development Tooling

Add pre-commit hooks (Black + Ruff), or equivalent scripts.

Ensure all Implementer GPT expectations in TECH_SPEC become enforceable.

Create Developer Automation

Any scripts, Makefile targets, or convenience commands chosen in Phase 0.

GPT RULE Activation

Once CI is online, the burden shifts from human reminders to CI enforcement.

Implementer GPTs no longer need to manually remind Andrew to run Black/Ruff locally.

üîí Why this note exists

Because LillyCORE currently consists only of:

The doc folders,

Specs,

Cards,

And no actual repository or automation ‚Äî

‚Äîthis note ensures Phase 1 builds the real foundations and nothing quietly slips through the cracks.

======================================================


