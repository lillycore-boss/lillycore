- id: modules.overview
  kind: overview
  md: |
    # Modules

    This file tracks **major engines and plugins** in LillyCORE (not individual features).

    In LillyCORE, we distinguish between:

    **Core engines (core modules):**
    - DRIFT_ENGINE       (2a) front/context/emotion
    - HELPER_ENGINE      (2b) work engine / helper
    - MODULE_ENGINE      module / plugin management
    - HELP_DESK_ENGINE   stability / auto-fix
    - DREAM_ENGINE       offline reasoning/maintenance
    - SCRIPT_ENGINE      script optimisation + self-maintenance

    **Plugins (add-on modules):**
    - UX_INTERFACE
    - PROJECT_MANAGEMENT
    - PERSONAL_ASSISTANT
    - NOTES_PLUGIN       (demo/testbed)
    - MULTI_USER
    - DEMOS_AND_CORP
    - Any future “extra capability” systems

    **Engines:**
    - Core of how Lilly thinks, works, and maintains itself.

    **Plugins:**
    - Built on top of engines.
    - Not part of the core runtime.

    ## Implementation layout (folder mapping)

    All engines are implemented under:
    - `engines/<engine_name>/`

    Examples:
    - `engines/drift_engine/`
    - `engines/helper_engine/`
    - `engines/plugin_engine/`
    - `engines/helpdesk_engine/`
    - `engines/dream_engine/`
    - `engines/script_engine/`

    All plugins are implemented under:
    - `plugins/<plugin_name>/`

    Examples:
    - `plugins/notes_plugin/`
    - `plugins/ux_interface/`
    - `plugins/project_management/`
    - `plugins/personal_assistant/`
    - `plugins/multi_user/`
    - `plugins/demos_and_corp/`

    The folder taxonomy for these modules is defined in tech_spec Section 3 and MUST be kept in sync with this overview.

    ## Dependency and boundary rules

    Engines may depend on:
    - `core/` (runtime loop, logging, AI pools, System DOC)
    - other engines where explicitly listed under "dependencies" in this modules file

    Engines MUST NOT import plugins directly; they see plugins only through PLUGIN_ENGINE / MODULE_ENGINE registries and capability interfaces.

    Plugins may depend on:
    - `core/` and `engines/`, as clients of those APIs

    Plugins MUST NOT:
    - be imported directly by `core/` or `engines/` (except via plugin registration and routing interfaces)
    - own or redefine System DOC schemas (plugins operate within the DOC layer boundaries defined by core/System DOC)

    ## This file answers

    - What engines and plugins exist?
    - When do they appear (which phase)?
    - What are they responsible for?
    - What do they depend on?

    Architect GPT can use this to:
    - Keep subsystems distinct.
    - Place new features in the right engine or plugin.

    QA GPT can use this to verify that implemented work respects module boundaries and responsibilities.

    Implementer GPT can use this for:
    - Context when touching specific engines/plugins.

- id: modules.allowed_kinds
  kind: meta
  md: |
    Allowed block kinds in this file:

    - overview
    - meta
    - entry_template
    - module

- id: modules.index
  kind: index
  md: |
    Blocks in this file:

    - modules.overview
      Overview and boundary/dependency notes for major modules.

    - modules.allowed_kinds
      Allowed block kinds for this file.

    - modules.index
      Index of blocks in this file.

    - modules.entry_template
      Template for module entries.

    - modules.core_runtime
      Core runtime loop, logging, and preference handling.

    - modules.ai_pools
      LLM pools and execution wrappers.

    - modules.system_doc
      Durable storage layer for system state and work logs.

    - modules.drift_engine
      2a “Lilly the Person” — front/context/emotion engine.

    - modules.helper_engine
      2b “Lilly the Worker” — executes work in context.

    - modules.plugin_engine
      Dynamic plugin loading/unloading and capability registry.

    - modules.help_desk_engine
      Stability spine — failure detection, auto-repair, escalation.

    - modules.dream_engine
      Offline reasoning, compression, drift correction.

    - modules.script_engine
      Automation script management and improvement.

    - modules.notes_plugin
      Notes demo/testbed plugin.

    - modules.ux_interface
      UI for chat/output/debug panels.

    - modules.project_management
      Internal project management plugin.

    - modules.personal_assistant
      User-facing assistant behaviour plugin.

    - modules.multi_user
      Multi-user identity and isolation plugin.

    - modules.io_network_layer
      Infra layer for cross-device communication.

    - modules.demos_and_corp
      Demo plugins and corp/enterprise-specific plugins.

- id: modules.entry_template
  kind: entry_template
  md: |
    Use this pattern for each entry:

    ```text
      type: core | engine | plugin | ui | infra
      phase: <roadmap phase number>
      status: planned | in-progress | implemented

      summary:
        Short description of what this owns.

      responsibilities:
        - bullet
        - bullet

      dependencies:
        - list engines/plugins/layers it needs

      notes:
        - any important constraints or decisions
    ```

- id: modules.core_runtime
  kind: module
  md: |
    type: core
    phase: 1
    status: in-progress

    summary:
      Phase 1 core runtime surface: interactive heartbeat loop skeleton with explicit seams for
      logging, settings, command ingress, and structured error propagation.

    responsibilities:
      - Provide a Phase 1 interactive (foreground) heartbeat loop: start → tick/step → stop.
      - Expose callable seams for:
        - command ingress adapter (P1.1.2)
        - settings load boundary (P1.1.3)
        - structured error envelope propagation surface (P1.1.4; envelope treated as opaque)
        - logging hooks/adapter calls (P1.1.5)
      - Provide a stop/request mechanism that enables Phase 1 graceful exit (shutdown semantics implemented in P1.1.6).
      - Avoid Phase 2+ behaviours (no daemon/service lifecycle, no multi-loop orchestration).

    dependencies:
      - None (foundational).

    notes:
      - Implementation surface for Phase 1 runtime is `lillycore/runtime/` (per P1.1.1 constraint).
      - Repo may temporarily contain a root-level `runtime/` directory from earlier prep; it is not the target surface for Phase 1 and should be treated as transitional until files are relocated.
      - Runtime system settings contract (P1.1.3):
        - canonical file: `lillycore/runtime/config/runtime.system.json` (JSON)
        - precedence: defaults < system settings file < temporary override
        - missing file behaviour: MUST fall back to defaults; SHOULD log a warning
        - Phase 1 heartbeat logging controls (P1.1.5): bounded tick emission is controlled by settings (e.g., `heartbeat_enabled`, `heartbeat_every_n_ticks`) and should avoid spam by default.
      - Interactive invocation is expected to run via a proof harness; runner is not a canonical API.
        - For running from the repo root folder without directory switching: `PYTHONPATH=.. python3 -m lillycore.run_runtime`
      - Command ingress semantics are transport-agnostic; Phase 1 provides a terminal-based adapter only.
      - Do NOT bake in assumptions that all engines are forever fused; future phases may split processes/machines.
      - Runtime produces envelopes at catch boundaries via an injected
        envelope_factory and forwards them to logging via envelope_sink.
      - Envelope objects are treated as opaque outside the authority module.
      - Phase 1 stop/shutdown semantics (P1.1.6):
        - Terminal stop commands: `stop` (plus `quit`/`exit`; adapter may also treat EOF as stop).
        - Stop is an internal control signal (RuntimeStopRequested) and MUST NOT be wrapped as an envelope.
        - Shutdown finalization: runtime will call logger finalization hooks if present (e.g., `finalize` / `flush` / `finish`).
        - Negative-path shutdown proof hook: `FORCE_SHUTDOWN_ERROR=1` forces an exception during shutdown (on_stop) which MUST be enveloped and logged.
      - Command ingress contract (P1.1.2 / command_ingress):
        - `CommandIngress.poll()` returns `None` (handler-based); runtime should not assume poll returns a list of commands.


    implementation:
      - lillycore/runtime/
        - heartbeat.py                  (core loop + lifecycle)
        - interactive_runner.py         (Phase 1 interactive entrypoint)
        - runtime_logger.py             (Phase 1 unified logging adapter; lifecycle, heartbeat, envelope hooks)
        - command_ingress.py            (ingress boundary / protocol)
        - terminal_ingress.py           (Phase 1 terminal-based ingress adapter)
        - config/runtime.system.json    (runtime system settings JSON; P1.1.3)
        - __init__.py                   (runtime package marker)
        - error_envelopes.py            (Runtime error wrapping authority)
      - run_runtime.py                  (manual interactive runner / proof harness)

- id: modules.ai_pools
  kind: module
  md: |
    type: core
    phase: 2
    status: planned

    summary:
      Encapsulates different LLM "brains" and execution wrappers.

    responsibilities:
      - Provide conversational, deterministic, and worker pools.
      - Wrap LLM calls with retries, timeouts, and envelopes.

    dependencies:
      - CORE_RUNTIME

    notes:
      - Backend choices (OpenAI, local models, etc.) are defined elsewhere.

- id: modules.system_doc
  kind: module
  md: |
    type: core
    phase: 3
    status: planned

    summary:
      Durable storage layer for system state and work logs.

    responsibilities:
      - Store work events.
      - Keep permanent logs.
      - Manage snapshots and final outputs (pdf/txt/img routing).

    dependencies:
      - CORE_RUNTIME

    notes:
      - Actual DB/storage engine is defined in tech_spec / future design.
      - Engines and plugins build on this.

- id: modules.drift_engine
  kind: module
  md: |
    type: engine
    phase: 5
    status: planned

    summary:
      2a – "Lilly the Person".
      Front/context/emotion engine that shapes how input is perceived.

    responsibilities:
      - Classify content as work / personal / ephemeral.
      - Apply emotional weights to experiences and memories.
      - Maintain personal memory entries.
      - Track ephemeral context (recent messages, tone).
      - Produce thread/context summaries as input to HELPER_ENGINE.

    dependencies:
      - SYSTEM_DOC
      - NOTES_PLUGIN (for testing / early flows)

    notes:
      - Name "DRIFT_ENGINE" reflects its role in managing emotional/contextual drift.
      - May eventually run in a separate process/machine from HELPER_ENGINE.

- id: modules.helper_engine
  kind: module
  md: |
    type: engine
    phase: 6
    status: planned

    summary:
      2b – "Lilly the Worker".
      Executes work given structured context from DRIFT_ENGINE.

    responsibilities:
      - Accept WorkPackage + ContextBundle.
      - Select appropriate work mode/type.
      - Call backend AIs or stubs.
      - Return structured results.
      - Log work events.

    dependencies:
      - AI_POOLS
      - DRIFT_ENGINE
      - SYSTEM_DOC

    notes:
      - Does not decide who Lilly is; it just does work in context.
      - May have its own runtime separate from DRIFT_ENGINE for stability.

- id: modules.plugin_engine
  kind: module
  md: |
    type: engine
    phase: 7
    status: planned

    summary:
      Manages dynamic loading/unloading and registry of plugins.

    responsibilities:
      - Register, load, and unload plugins at runtime.
      - Maintain a capability registry for all plugins.
      - Route calls to plugin sandboxes.
      - Keep per-plugin DOC boundaries sane and isolated.

    dependencies:
      - CORE_RUNTIME
      - SYSTEM_DOC (for plugin-level DOCs)

    notes:
      - Previously called "Module Handler" → "Module Engine".
      - Now definitively called PLUGIN_ENGINE to align with plugin terminology.

- id: modules.help_desk_engine
  kind: module
  md: |
    type: engine
    phase: 8
    status: planned

    summary:
      Detects and responds to repeated failures in the system.

    responsibilities:
      - Detect recurring errors or failing operations.
      - Attempt auto-repair or mitigation.
      - Escalate issues to Andrew when needed.
      - Distinguish fatal vs recoverable failures.

    dependencies:
      - CORE_RUNTIME
      - SYSTEM_DOC
      - MODULE_ENGINE (for plugin-level fixes, later).

    notes:
      - Part of the "stability spine" along with DREAM_ENGINE and SCRIPT_ENGINE.

- id: modules.dream_engine
  kind: module
  md: |
    type: engine
    phase: 8
    status: planned

    summary:
      Performs offline reasoning, compression, and drift correction.

    responsibilities:
      - Degrade or compress memories over time.
      - Compress System DOC data where appropriate.
      - Perform lateral reasoning about past events.
      - Evaluate drift and propose optimizations.

    dependencies:
      - SYSTEM_DOC
      - DRIFT_ENGINE

    notes:
      - Intended to run during downtime or scheduled windows.

- id: modules.script_engine
  kind: module
  md: |
    type: engine
    phase: 8
    status: planned

    summary:
      Manages and improves automation scripts used by LillyCORE.

    responsibilities:
      - Analyze and optimize internal scripts.
      - Merge/split script units for clarity and reuse.
      - Validate changes in a sandbox.
      - Optionally auto-approve safe improvements.

    dependencies:
      - CORE_RUNTIME
      - tech_spec (for script standards).

    notes:
      - Works with HELP_DESK_ENGINE and DREAM_ENGINE for self-maintenance.

- id: modules.notes_plugin
  kind: module
  md: |
    type: plugin
    phase: 4
    status: planned

    summary:
      Simple notes subsystem; primarily a demo / testbed.

    responsibilities:
      - Summarize transcripts.
      - Accumulate notes.
      - Support basic queries over notes.

    dependencies:
      - SYSTEM_DOC

    notes:
      - Used heavily by DRIFT_ENGINE as an early, cheap test surface.
      - This is NOT a core engine; it is a plugin/demo.

- id: modules.ux_interface
  kind: module
  md: |
    type: ui
    phase: 9
    status: planned

    summary:
      Chat, output, and debug panels for interacting with LillyCORE.

    responsibilities:
      - Provide a chat interface.
      - Display outputs and errors.
      - Surface identity and personality cues.

    dependencies:
      - HELPER_ENGINE
      - CORE_RUNTIME

    notes:
      - UX is a plugin-level concern, not a core engine.

- id: modules.project_management
  kind: module
  md: |
    type: plugin
    phase: 10
    status: planned

    summary:
      Internal project management tooling inside LillyCORE.

    responsibilities:
      - Task breakdown.
      - Work tracking.
      - Self-roadmapping.

    dependencies:
      - SYSTEM_DOC
      - HELPER_ENGINE

- id: modules.personal_assistant
  kind: module
  md: |
    type: plugin
    phase: 11
    status: planned

    summary:
      User-facing assistant behaviour.

    responsibilities:
      - Daily briefings.
      - Summaries.
      - Routine tracking.
      - Calendar-like memory.

    dependencies:
      - DRIFT_ENGINE
      - HELPER_ENGINE
      - NOTES_PLUGIN

- id: modules.multi_user
  kind: module
  md: |
    type: plugin
    phase: 13
    status: planned

    summary:
      Multi-user identity and isolation.

    responsibilities:
      - Per-user memory.
      - Per-user plugin data.
      - Route threads to correct user identity.

    dependencies:
      - SYSTEM_DOC
      - DRIFT_ENGINE
      - HELPER_ENGINE

- id: modules.io_network_layer
  kind: module
  md: |
    type: infra
    phase: 14
    status: planned

    summary:
      Communication across devices.

    responsibilities:
      - Unified packet format.
      - LAN endpoints.
      - Voice/wake commands.
      - Device sandbox coordination.

    dependencies:
      - CORE_RUNTIME
      - UX_INTERFACE

    notes:
      - Appliance / hardware specifics defined later.

- id: modules.demos_and_corp
  kind: module
  md: |
    type: plugin
    phase: 12+
    status: future

    summary:
      Demo plugins (calculator, story helper, etc.) and any corp/enterprise-specific plugins.

    responsibilities:
      - Showcase capabilities.
      - Provide focused functionality built on core engines.

    dependencies:
      - HELPER_ENGINE (usually)
      - DRIFT_ENGINE (where context/personality matters)

