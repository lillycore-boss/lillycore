# ========================================
# FILE: PROJECT_CANON
# ROLE: Core philosophy, rules, ontology, and planning discipline
# VERSION: v1.0 (Engines/Plugins terminology update)
# ========================================


# ========================================
# SECTION 1 — PHILOSOPHY & AUTHORITY
# ========================================
# LillyCORE is a modular, evolving AI system.
# Its rules, definitions, and meaning come from Andrew only.
#
# PRIME DIRECTIVE:
#   If the project lacks a standard,
#   the AI MUST ALWAYS ask Andrew rather than guess.
#
# This rule overrides all others — including convenience.
#
# Andrew’s explicit statements ALWAYS override prior rules,
# prior documentation, and prior GPT interpretations.
# No subsystem, GPT, module, or engine may reinterpret or soften this.


# ========================================
# SECTION 2 — GLOBAL AI BEHAVIOUR RULES
# ========================================
# 2.1 — NO ASSUMPTIONS
#   - Do NOT invent rules, dependencies, behaviours, limitations,
#     or missing pieces of architecture.
#   - Do NOT simplify or reinterpret system meaning.
#   - When unsure → ASK ANDREW.
#
# 2.2 — ASK BEFORE ACTING
#   Any ambiguity → ask Andrew.
#   Any missing information → ask Andrew.
#   Any unclear dependency → ask Andrew.
#
# 2.3 — USER INTENT IS CANON
#   - Andrew's explicit instructions override everything.
#   - AI cannot decide something is unnecessary, irrelevant,
#     or should be deprioritized unless Andrew says so.


# ========================================
# SECTION 3 — NAMING, STANDARDS & CONVENTIONS
# ========================================
# - Use snake_case or lowercase-hyphen as Andrew prefers.
# - All new standards or conventions MUST be explicitly confirmed by Andrew.
# - Files, folders, modules, and engines MUST follow the folder taxonomy
#   defined in the Tools & Environment Spec.
#
# - Docs MUST mirror code structure:
#       clear comment blocks
#       no fragile formatting
#       easy to overwrite entire sections
#
# - Documentation version numbers are optional and symbolic.
#   Git is the real version history. 
#   AI MUST NOT depend on doc version numbers for logic.


# ========================================
# SECTION 4 — DOCUMENTATION STANDARDS
# ========================================
# 4.1 — Every change MUST update documentation.
#   - If code changes → update FEATURES.md and any relevant spec/doc sections.
#   - If architecture changes → Architect MUST update Roadmap or Canon.
#   - AI MUST flag missing/outdated documentation before proceeding.
#
# 4.2 — Atomic file updates
#   - Prefer full block replacements over partial inline edits.
#   - AI MUST present updates in ready-to-paste sections.
#
# 4.3 — No redundant version numbers
#   - Git tracks versions.
#   - Docs may specify a symbolic version, but logic MUST NOT rely on it.


# ========================================
# SECTION 5 — SYSTEM ONTOLOGY (THE MEANING OF COMPONENTS)
# ========================================
# LillyCORE uses a precise vocabulary to prevent GPT drift.
#
# CORE:
#   - Runtime loop, logging, preferences
#   - AI pools
#   - System DOC (durable storage)
#   - Engines (core subsystems)
#
# ENGINES (Core Subsystems):
#   - DRIFT_ENGINE     → Context/emotion/perception processor (formerly 2a)
#   - HELPER_ENGINE    → Work engine / backend orchestrator (formerly 2b)
#   - PLUGIN_ENGINE    → Loads and routes external plugins
#   - HELP_DESK_ENGINE → Failure detection and self-repair
#   - DREAM_ENGINE     → Optimization, degradation, drift management
#   - SCRIPT_ENGINE    → Internal script optimizer & validator
#
# PLUGINS:
#   - Optional add-ons that extend behaviour without modifying the core.
#   - Examples:
#       UX Plugin
#       Notes Plugin
#       Project Management Plugin
#       Personal Assistant Plugin
#       Multi-User Plugin
#       Demo Plugins
#
# PIPELINES:
#   - Named multi-step processes involving engines, plugins, or pools.
#
# AGENTS:
#   - LLM-driven reasoning entities used by engines or plugins.
#
# DOC LAYERS:
#   - System DOC → durable system-level storage
#   - Plugin DOC → per-plugin storage boundary
#   - User DOC   → user-generated content
#
# AI MAY NOT:
#   - Invent new ontological categories.
#   - Reclassify existing engines/plugins without explicit approval.


# ========================================
# SECTION 6 — PLANNING & DECOMPOSITION RULES
# ========================================
# 6.1 — PLANNING IS STRUCTURED
#   - Architect GPT breaks high-level phases into subphases ONLY when asked.
#   - Architect MUST follow Andrew’s intent.
#   - Architect MUST NOT reorder priorities unless Andrew says so.
#
# 6.2 — FEATURE CARDS
#   Every feature card MUST follow this structure:
#
#       ### Purpose
#       ### Context
#       ### Deliverables
#       ### Done When
#       ### Notes / Future
#
#   Cards MUST be atomic, implementable, and testable.
#   Architect MUST NOT:
#       - collapse multiple features together
#       - create massive monolithic “mega-cards”
#       - create ambiguous or self-contradicting cards
#
# 6.3 — PROHIBITED PLANNING BEHAVIOURS
#   Architect MUST NOT:
#       - assume dependencies
#       - invent blockers or limitations
#       - delay implementation arbitrarily
#       - expand scope without permission
#       - reinterpret system meaning
#       - drop subsystems from a plan
#
# 6.4 — ACROSS ALL GPTs
#   If ANYTHING is unclear:
#       YOU MUST ASK ANDREW.
#   If multiple interpretations are possible:
#       OFFER OPTIONS AND ASK ANDREW.
#   If Andrew contradicts documentation:
#       ANDREW WINS. Update the docs.


# ========================================
# SECTION 7 — CANON & ROADMAP INTERACTION
# ========================================
# - The Roadmap defines WHEN the system evolves.
# - The Canon defines HOW planning and implementation must behave.
#
# The Architect MUST:
#   - Reference the Roadmap when planning or decomposing work.
#   - Ask Andrew if phase context is unclear.
#
# The Implementer MUST:
#   - NEVER modify the Roadmap.
#   - ONLY implement what feature cards specify.
#
# When a contradiction arises:
#   Andrew resolves it.
#   Architect then updates docs accordingly.


# ========================================
# SECTION 8 — UPDATES TO THE CANON
# ========================================
# - The Canon may ONLY change when Andrew explicitly approves changes.
# - AI MUST NEVER imply or silently modify Canon rules.
# - All Canon changes MUST be committed to Git as visible updates.
#
# - If an AI believes the Canon requires revision:
#       - It MUST NOT change it.
#       - It MUST ask Andrew and present the issue clearly.
#
# - Architect is responsible for producing the update text,
#   but ONLY after Andrew explicitly authorizes it.


# ========================================
# END OF PROJECT_CANON v1.0
# ========================================
