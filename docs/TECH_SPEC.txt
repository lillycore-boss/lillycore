# ========================================
# FILE: TECH_SPEC
# ROLE: Technical standards and environment details for LillyCORE
# NOTE: This file defines HOW we build and run things, not WHAT the system is.
# ========================================


# ========================================
# SECTION 1: RUNTIMES AND LANGUAGES
# ========================================
# Primary language:
#   - Python 3.11+ (CPython)
#
# Runtime support (Phases 1–3):
#   - Minimum required version: CPython 3.11
#   - Officially supported/tested range: CPython 3.11–3.14 (inclusive)
#   - Recommended development version: CPython 3.13
#
# Notes (Python version rationale, Phases 1–3):
#   - 3.10 is already in security-only support and will reach EOL during the
#     Phase 1–3 timeline, so we do NOT target it as a minimum.
#   - 3.11–3.14 have long support windows and are fully compatible with modern
#     tooling (formatter, linter, test framework).
#   - We recommend 3.13 for development to benefit from newer performance
#     features while keeping the codebase compatible with 3.11+.
#
# Rules:
#   - Always target python3, NEVER python2.
#   - All runtime code for Phases 1–3 MUST run on CPython 3.11–3.14.
#   - Prefer standard library unless a dependency is explicitly approved.
#
# Other languages (if any):
#   - (e.g. shell scripts, TypeScript for UI, etc. — leave blank or TODO)
#
# TODO:
#   - List any pre-approved third-party libraries once decided.


# ========================================
# SECTION 2: CODE STYLE & COMMENTS
# ========================================
# General style:
#   - Follow Pythonic conventions (PEP8-ish, but Andrew is the final authority).
#
# Formatter:
#   - LillyCORE USES an auto-formatter for all Python code.
#   - Chosen formatter: Black.
#   - All Python code committed to the repo MUST be formatted with Black.
#   - We use Black's defaults; no custom style overrides beyond its standard behaviour.
#   - Effective line length is Black's default (currently 88 characters).
#
# Comments:
#   - Use "#" for line comments.
#   - For larger logical blocks in config/docs, use this pattern:
#     # ========================================
#     # SECTION: NAME
#     # ========================================
#
# Naming conventions:
#   - snake_case for functions and variables.
#   - lowercase_with_underscores or lowercase-hyphen for files/folders (Andrew to confirm).
#
# Workflow expectations:
#   - Developers SHOULD configure their editor to format-on-save with Black for .py files.
#   - If format-on-save is not used, developers MUST run Black manually before committing.
#   - When git hooks/CI are introduced:
#       - A pre-commit hook SHOULD run Black on staged Python files.
#       - CI SHOULD include a check that fails if running Black would change the codebase.
#   - Exact hook framework (e.g., shell scripts vs additional tooling) and script paths
#     will be defined in a future task; this section only defines the formatter and policy.
#
# GPT RULE:
#   - If any style or naming detail is unclear, ASK Andrew instead of guessing.
#   - GPTs MUST assume that all Python examples and new files are Black-formatted.
#
#
# Linting:
#   - LillyCORE USES a Python linter for all runtime Python code.
#   - Chosen linter: Ruff.
#   - Ruff is the single source of truth for lint checks; we do NOT run flake8 or pylint
#     in addition to Ruff for early phases (0–3).
#
#   Scope:
#   - All non-generated Python code in the repository is expected to be Ruff-clean
#     under the agreed rule set.
#   - Any exceptions (e.g., generated code or external vendored code) MUST be explicitly
#     excluded via Ruff configuration in the repo.
#
#   Strictness philosophy (Phases 0–3):
#   - Goal: catch real bugs and keep the codebase clean, without over-policing style.
#   - We adopt a “standard” strictness in early phases:
#       - ENABLE high-signal rule families:
#           - Core correctness and hygiene (undefined names, unused imports/variables, etc.).
#           - Style rules that are compatible with Black's formatting.
#           - Import hygiene and ordering.
#       - DO NOT enforce in early phases:
#           - Docstring coverage / style (no pydocstyle-style requirements).
#           - Project-wide mandatory type annotations.
#           - Complexity / design metrics (e.g., cyclomatic complexity limits).
#           - Hyper-pedantic style rules that create noise without clear benefit.
#
#   Enforcement model:
#   - All active Ruff rules are treated as errors in CI once CI exists:
#       - If Ruff reports an error on the current codebase, the lint job fails.
#   - Developers SHOULD run Ruff locally (manually, via editor integration, or via scripts)
#     before pushing changes.
#   - When git hooks are introduced:
#       - A pre-commit hook SHOULD run Ruff on staged Python files, alongside Black.
#
#   Rule configuration:
#   - Ruff configuration (which rule families are enabled/disabled) MUST live in a
#     central, version-controlled config file (e.g., pyproject.toml or equivalent),
#     to be defined when the repository structure is finalized.
#   - Any per-file or per-rule ignores:
#       - MUST be justified with a short comment in-code or in the config.
#       - SHOULD be as narrow as possible (e.g., specific rule on a specific line/file).
#
#   Future tightening:
#   - As LillyCORE matures, additional rule families (e.g., docstring and type-annotation
#     enforcement, complexity metrics) MAY be enabled in later phases, subject to
#     explicit decisions and TECH_SPEC updates.
#
# ---------------------------------------------
# TYPING & TYPE CHECKING
# ---------------------------------------------
# Typing Philosophy (Phases 0–3):
#   - LillyCORE uses Python type hints (PEP 484+).
#   - Type hints are ENCOURAGED for all new code.
#   - Type hints are ENFORCED for core runtime and engine modules.
#
# Strict Typing Set:
#   - The following modules MUST remain type-clean and fully annotated:
#       - core/:
#           - CORE_RUNTIME
#           - AI_POOLS
#           - SYSTEM_DOC
#       - Engines:
#           - DRIFT_ENGINE
#           - HELPER_ENGINE
#           - PLUGIN_ENGINE
#           - HELP_DESK_ENGINE
#           - DREAM_ENGINE
#           - SCRIPT_ENGINE
#
# Non-strict Modules:
#   - Plugins and experimental modules:
#       - Type hints strongly encouraged.
#       - Public APIs SHOULD be typed.
#       - mypy may run in non-strict mode.
#
# Static Type Checker:
#   - LillyCORE uses mypy for static type checking.
#   - mypy configuration MUST live at repo root.
#   - mypy MUST be configured for Python 3.11+.
#
# Enforcement Model:
#   - Strict modules must:
#       - Use type hints consistently.
#       - Pass mypy with zero errors before merge.
#   - Non-strict modules:
#       - Allowed to have non-blocking mypy warnings during early phases.
#
# CI Expectations:
#   - CI MUST fail if:
#       - mypy reports errors in strict modules.
#   - mypy MAY run in informational mode for the rest of the codebase.
#
# GPT RULE (Typing):
#   - GPTs MUST add type hints to all public functions.
#   - GPTs SHOULD add hints to internal helpers.
#   - For strict-set files, GPTs MUST maintain mypy cleanliness.
#   - If an ignore is required:
#       - It MUST be justified and as narrow as possible.


# ========================================
# SECTION 3: REPOSITORY LAYOUT
# ========================================
# (This is intentionally light for now; will grow with the project.)
#
# Top-level folders (initial standard for early phases):
#   - core/        -> runtime loop, logging, core services
#   - modules/     -> plug-in modules (Notes Plugin, etc.)
#   - scripts/     -> maintenance / helper / dev scripts
#   - docs/        -> human-facing docs (optional)
#   - tests/       -> pytest-based automated tests
#
# Test layout:
#   - All automated Python tests live under tests/.
#   - Where practical, tests SHOULD mirror the runtime layout:
#       - tests/core/     for tests of code in core/
#       - tests/modules/  for tests of code in modules/
#       - tests/scripts/  for tests of code in scripts/
#   - Additional subdirectories under tests/ MAY be added to mirror new
#     top-level folders as they are introduced, but MUST follow the same
#     “mirror the runtime layout” pattern.
#
# GPT RULES:
#   - Do NOT invent new top-level folders without approval.
#   - If unsure where something belongs, ASK Andrew:
#       "Should this live in core/, modules/, or somewhere else?"
#
# TODO:
#   - Fill in additional folder names once Phase 0 is implemented (e.g. where
#     configs and environment definitions live).
#   - Lock in a standard for where configs live (e.g. config/ or inside core/).


# ========================================
# SECTION 4: LOGGING & ERROR HANDLING
# ========================================
# Logging:
#   - There will be a unified logging system (defined in Phase 1).
#   - All new code that does meaningful work SHOULD log via that system once it exists.
#
# Errors:
#   - Prefer explicit exceptions over silent failure.
#   - Wrap external/IO calls where appropriate with clear error envelopes (as per design).
#
# GPT RULE:
#   - If logging or error envelope APIs are not defined yet, do NOT invent them.
#   - Instead, note in PLAN/DOC:
#       "Logging/error handling integration TBD once core logging is defined."
#
# TODO:
#   - Define the actual logging interface once Phase 1 is built.


# ========================================
# SECTION 5: SCRIPTS & CLI TOOLS
# ========================================
# Script expectations:
#   - Scripts should be runnable via python3 from the repo root unless otherwise specified.
#   - Prefer argument-based CLIs (e.g. argparse) over interactive prompts for automation.
#
# Behaviour:
#   - Scripts SHOULD:
#       - Exit with non-zero status on failure.
#       - Print clear error messages for humans if they fail.
#
# GPT RULE:
#   - Do NOT assume a script name or path.
#   - If a script is needed, propose a name and location, and ASK Andrew to confirm.


# ========================================
# SECTION 6: STORAGE & DATABASE
# ========================================
# Current state:
#   - System DOC is conceptually defined in the Roadmap.
#   - No specific DB engine is frozen yet (e.g. SQLite vs Postgres).
#
# Interim rules:
#   - For early prototypes, prefer file-based or in-memory options UNLESS Andrew says otherwise.
#   - The Architect must NOT commit the system to a specific database without Andrew’s explicit decision.
#
# GPT RULE:
#   - If a feature needs persistence, ASK:
#       "For this feature, should we use a simple file approach, in-memory, or design for a future DB?"
#
# TODO:
#   - Decide on default DB (if any) for early phases.
#   - Document connection patterns once chosen.


# ========================================
# SECTION 7: ENVIRONMENTS & HARDWARE
# ========================================
# Development environment:
#   - Assume Andrew is developing on local hardware (exact OS/hardware to be clarified if needed).
#
# Hardware constraints:
#   - Do NOT assume GPU availability.
#   - Do NOT assume multi-machine cluster.
#
# GPT RULE:
#   - If hardware affects a design (e.g. heavy parallelism, GPU ops), ASK Andrew first.
#
# TODO:
#   - Specify OS assumptions if they become important (e.g. Linux vs Windows paths).
#   - Document any future dedicated appliance constraints (for Appliance Layer / Phase 15).


# ========================================
# SECTION 8: TESTING
# ========================================
# General approach:
#   - LillyCORE uses automated tests to validate behaviour where practical.
#   - Small, focused tests or usage examples are preferred over large,
#     monolithic suites.
#
# Chosen test framework:
#   - Python test framework: pytest.
#   - Rationale:
#       - Widely used, stable, and integrates well with Black, Ruff, and mypy.
#       - Current pytest releases support all actively maintained Python
#         versions in the LillyCORE target range (CPython 3.11–3.14).
#   - Developers are expected to install a pytest version compatible with the
#     supported Python versions defined in Section 1.
#
# Test layout and discovery:
#   - All automated tests live under the top-level tests/ directory.
#   - Where practical, tests SHOULD mirror the runtime layout:
#       - tests/core/     for tests of code in core/
#       - tests/modules/  for tests of code in modules/
#       - tests/scripts/  for tests of code in scripts/
#   - Test files MUST follow pytest’s default discovery pattern:
#       - Python test modules are named: test_*.py
#         (e.g. test_core_runtime.py, test_system_doc_storage.py).
#   - Additional organisational subdirectories under tests/ MAY be created
#     as the codebase grows, provided they follow the same “mirror the
#     runtime layout” intent.
#
# Running tests:
#   - From the repository root, the standard way to run the test suite is:
#       - pytest
#     or equivalently:
#       - python -m pytest
#   - All test-running examples and scripts SHOULD assume the repo root as
#     the working directory unless otherwise specified.
#
# GPT RULE:
#   - When implementing non-trivial behaviour, propose at least:
#       - A pytest unit-test skeleton, OR
#       - A simple manual test procedure, if writing a test is clearly out
#         of scope for the current card.
#
# CI and static checks:
#   - Once CI is configured for LillyCORE, the minimum expected checks are:
#       - Black formatting check (no changes when Black is run).
#       - Ruff lint check under the configured rule set.
#       - mypy type-checker for the configured strict set of modules
#         (see Section 2: Typing & type checking).
#       - The pytest test suite (run via pytest from the repo root).
#   - CI SHOULD fail if:
#       - Black would reformat any committed Python file, OR
#       - Ruff reports lint errors for the current codebase, OR
#       - mypy reports type errors in the strict set of modules, OR
#       - pytest tests fail.
#   - Additional static analysis tools beyond Black/Ruff/mypy/pytest MAY be
#     added in future tasks and will be documented here when chosen.


# ========================================
# SECTION 9: GPT-SPECIFIC NOTES
# ========================================
# For Architect, Implementer, and QA GPTs:
# - NEVER:
#     - invent libraries
#     - invent folder structures
#     - invent tools or CLIs
#   without Andrew’s explicit approval.
#
# - ALWAYS:
#     - Ask for clarification when technical constraints matter.
#     - Treat this TECH_SPEC as evolving; if something feels missing:
#         Ask:
#         "Should we add this rule or choice to TECH_SPEC?"
#
# - QA GPT uses TECH_SPEC to verify that implemented work follows the correct technical standards.
#
# This file is living documentation and will grow as LillyCORE matures.


# ========================================
# SECTION 10: EXAMPLES
# ========================================
#
# Example Type Signatures (Python 3.11+)
#
#   from pathlib import Path
#   from collections.abc import Sequence
#   from typing import Any
#
#   def load_user_preferences(path: Path) -> dict[str, Any]:
#       """Load user preferences from disk."""
#       ...
#
#   def run_core_loop(config: CoreConfig, *, dry_run: bool = False) -> int:
#       """Run the CORE_RUNTIME loop and return an exit code."""
#       ...
#
#   def summarize_transcript(
#       lines: Sequence[str],
#       max_tokens: int | None = None,
#   ) -> str:
#       """Summarize transcript text for NOTES_PLUGIN."""
#       ...
#
# Notes:
#   - Examples here illustrate expected annotation style, not behavior.
#   - All examples assume Python 3.11+ type syntax.


# ========================================
# END OF TECH_SPEC
# ========================================
