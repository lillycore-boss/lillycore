# ========================================
# FILE: TECH_SPEC
# ROLE: Technical standards and environment details for LillyCORE
# NOTE: This file defines HOW we build and run things, not WHAT the system is.
# ========================================


# ========================================
# SECTION 1: RUNTIMES AND LANGUAGES
# ========================================
# Primary language:
#   - Python 3.11+ (CPython)
#
# Runtime support (Phases 1–3):
#   - Minimum required version: CPython 3.11
#   - Officially supported/tested range: CPython 3.11–3.14 (inclusive)
#   - Recommended development version: CPython 3.13
#
# Notes (Python version rationale, Phases 1–3):
#   - 3.10 is already in security-only support and will reach EOL during the
#     Phase 1–3 timeline, so we do NOT target it as a minimum.
#   - 3.11–3.14 have long support windows and are fully compatible with modern
#     tooling (formatter, linter, test framework).
#   - We recommend 3.13 for development to benefit from newer performance
#     features while keeping the codebase compatible with 3.11+.
#
# Rules:
#   - Always target python3, NEVER python2.
#   - All runtime code for Phases 1–3 MUST run on CPython 3.11–3.14.
#   - Prefer standard library unless a dependency is explicitly approved.
#
# Other languages (if any):
#   - (e.g. shell scripts, TypeScript for UI, etc. — leave blank or TODO)
#
# TODO:
#   - List any pre-approved third-party libraries once decided.


# ========================================
# SECTION 2: CODE STYLE & COMMENTS
# ========================================
# General style:
#   - Follow Pythonic conventions (PEP8-ish, but Andrew is the final authority).
#
# Formatter:
#   - LillyCORE USES an auto-formatter for all Python code.
#   - Chosen formatter: Black.
#   - All Python code committed to the repo MUST be formatted with Black.
#   - We use Black's defaults; no custom style overrides beyond its standard behaviour.
#   - Effective line length is Black's default (currently 88 characters).
#
# Comments:
#   - Use "#" for line comments.
#   - For larger logical blocks in config/docs, use this pattern:
#     # ========================================
#     # SECTION: NAME
#     # ========================================
#
# Naming conventions:
#   - snake_case for functions and variables.
#   - lowercase_with_underscores or lowercase-hyphen for files/folders (Andrew to confirm).
#
# Workflow expectations:
#   - Developers SHOULD configure their editor to format-on-save with Black for .py files.
#   - If format-on-save is not used, developers MUST run Black manually before committing.
#   - When git hooks/CI are introduced:
#       - A pre-commit hook SHOULD run Black on staged Python files.
#       - CI SHOULD include a check that fails if running Black would change the codebase.
#   - Exact hook framework (e.g., shell scripts vs additional tooling) and script paths
#     will be defined in a future task; this section only defines the formatter and policy.
#
# GPT RULE:
#   - If any style or naming detail is unclear, ASK Andrew instead of guessing.
#   - GPTs MUST assume that all Python examples and new files are Black-formatted.
#
#
# Linting:
#   - LillyCORE USES a Python linter for all runtime Python code.
#   - Chosen linter: Ruff.
#   - Ruff is the single source of truth for lint checks; we do NOT run flake8 or pylint
#     in addition to Ruff for early phases (0–3).
#
#   Scope:
#   - All non-generated Python code in the repository is expected to be Ruff-clean
#     under the agreed rule set.
#   - Any exceptions (e.g., generated code or external vendored code) MUST be explicitly
#     excluded via Ruff configuration in the repo.
#
#   Strictness philosophy (Phases 0–3):
#   - Goal: catch real bugs and keep the codebase clean, without over-policing style.
#   - We adopt a “standard” strictness in early phases:
#       - ENABLE high-signal rule families:
#           - Core correctness and hygiene (undefined names, unused imports/variables, etc.).
#           - Style rules that are compatible with Black's formatting.
#           - Import hygiene and ordering.
#       - DO NOT enforce in early phases:
#           - Docstring coverage / style (no pydocstyle-style requirements).
#           - Project-wide mandatory type annotations.
#           - Complexity / design metrics (e.g., cyclomatic complexity limits).
#           - Hyper-pedantic style rules that create noise without clear benefit.
#
#   Enforcement model:
#   - All active Ruff rules are treated as errors in CI once CI exists:
#       - If Ruff reports an error on the current codebase, the lint job fails.
#   - Developers SHOULD run Ruff locally (manually, via editor integration, or via scripts)
#     before pushing changes.
#   - When git hooks are introduced:
#       - A pre-commit hook SHOULD run Ruff on staged Python files, alongside Black.
#
#   Rule configuration:
#   - Ruff configuration (which rule families are enabled/disabled) MUST live in a
#     central, version-controlled config file (e.g., pyproject.toml or equivalent),
#     to be defined when the repository structure is finalized.
#   - Any per-file or per-rule ignores:
#       - MUST be justified with a short comment in-code or in the config.
#       - SHOULD be as narrow as possible (e.g., specific rule on a specific line/file).
#
#   Future tightening:
#   - As LillyCORE matures, additional rule families (e.g., docstring and type-annotation
#     enforcement, complexity metrics) MAY be enabled in later phases, subject to
#     explicit decisions and TECH_SPEC updates.


# ========================================
# SECTION 3: REPOSITORY LAYOUT
# ========================================
# (This is intentionally light for now; will grow with the project.)
#
# Likely top-level folders (example / TODO):
#   - core/        -> runtime loop, logging, core services
#   - modules/     -> plug-in modules (Notes Engine, etc.)
#   - scripts/     -> maintenance / helper / dev scripts
#   - docs/        -> human-facing docs (optional)
#   - tests/       -> tests (when they exist)
#
# GPT RULES:
#   - Do NOT invent new folders without approval.
#   - If unsure where something belongs, ASK Andrew:
#       "Should this live in core/, modules/, or somewhere else?"
#
# TODO:
#   - Fill in actual folder names once Phase 0 is implemented.
#   - Lock in a standard for where configs live (e.g. config/ or inside core/).


# ========================================
# SECTION 4: LOGGING & ERROR HANDLING
# ========================================
# Logging:
#   - There will be a unified logging system (defined in Phase 1).
#   - All new code that does meaningful work SHOULD log via that system once it exists.
#
# Errors:
#   - Prefer explicit exceptions over silent failure.
#   - Wrap external/IO calls where appropriate with clear error envelopes (as per design).
#
# GPT RULE:
#   - If logging or error envelope APIs are not defined yet, do NOT invent them.
#   - Instead, note in PLAN/DOC:
#       "Logging/error handling integration TBD once core logging is defined."
#
# TODO:
#   - Define the actual logging interface once Phase 1 is built.


# ========================================
# SECTION 5: SCRIPTS & CLI TOOLS
# ========================================
# Script expectations:
#   - Scripts should be runnable via python3 from the repo root unless otherwise specified.
#   - Prefer argument-based CLIs (e.g. argparse) over interactive prompts for automation.
#
# Behaviour:
#   - Scripts SHOULD:
#       - Exit with non-zero status on failure.
#       - Print clear error messages for humans if they fail.
#
# GPT RULE:
#   - Do NOT assume a script name or path.
#   - If a script is needed, propose a name and location, and ASK Andrew to confirm.


# ========================================
# SECTION 6: STORAGE & DATABASE
# ========================================
# Current state:
#   - System DOC is conceptually defined in the Roadmap.
#   - No specific DB engine is frozen yet (e.g. SQLite vs Postgres).
#
# Interim rules:
#   - For early prototypes, prefer file-based or in-memory options UNLESS Andrew says otherwise.
#   - The Architect must NOT commit the system to a specific database without Andrew’s explicit decision.
#
# GPT RULE:
#   - If a feature needs persistence, ASK:
#       "For this feature, should we use a simple file approach, in-memory, or design for a future DB?"
#
# TODO:
#   - Decide on default DB (if any) for early phases.
#   - Document connection patterns once chosen.


# ========================================
# SECTION 7: ENVIRONMENTS & HARDWARE
# ========================================
# Development environment:
#   - Assume Andrew is developing on local hardware (exact OS/hardware to be clarified if needed).
#
# Hardware constraints:
#   - Do NOT assume GPU availability.
#   - Do NOT assume multi-machine cluster.
#
# GPT RULE:
#   - If hardware affects a design (e.g. heavy parallelism, GPU ops), ASK Andrew first.
#
# TODO:
#   - Specify OS assumptions if they become important (e.g. Linux vs Windows paths).
#   - Document any future dedicated appliance constraints (for Appliance Layer / Phase 15).


# ========================================
# SECTION 8: TESTING
# ========================================
# General approach:
#   - Tests are encouraged but not fully standardized yet.
#   - Small, focused tests or usage examples are preferred.
#
# GPT RULE:
#   - When implementing non-trivial behaviour, propose at least:
#       - A unit-test skeleton, OR
#       - A simple manual test procedure.
#
# TODO:
#   - Agree on test framework (e.g. pytest).
#   - Define folder/filename conventions for tests.
#
# CI and static checks:
#   - Once CI is configured for LillyCORE, the minimum expected checks are:
#       - Black formatting check (no changes when Black is run).
#       - Ruff lint check under the configured rule set.
#       - The chosen test suite (once a framework is selected).
#   - CI SHOULD fail if:
#       - Black would reformat any committed Python file, OR
#       - Ruff reports lint errors for the current codebase, OR
#       - Tests fail.
#   - Additional static analysis tools (e.g., type checkers) MAY be added in future
#     tasks and will be documented here when chosen.


# ========================================
# SECTION 9: GPT-SPECIFIC NOTES
# ========================================
# For Architect, Implementer, and QA GPTs:
# - NEVER:
#     - invent libraries
#     - invent folder structures
#     - invent tools or CLIs
#   without Andrew’s explicit approval.
#
# - ALWAYS:
#     - Ask for clarification when technical constraints matter.
#     - Treat this TECH_SPEC as evolving; if something feels missing:
#         Ask:
#         "Should we add this rule or choice to TECH_SPEC?"
#
# - QA GPT uses TECH_SPEC to verify that implemented work follows the correct technical standards.
#
# This file is living documentation and will grow as LillyCORE matures.


# ========================================
# END OF TECH_SPEC
# ========================================
