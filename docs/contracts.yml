- id: contracts.overview
  kind: overview
  md: |
    Canonical Phase 1 contracts for LillyCORE runtime behaviour surfaces.

    Scope (Phase 1):
    - Logging + error envelopes (schemas + wiring rules).
    - Runtime system settings (“preferences”) contract:
      - canonical file + format
      - schema shape + namespacing rules
      - precedence / override semantics
      - safe failure behaviour + logging/envelope reporting requirements

    Non-scope (Phase 1):
    - Runtime implementation details (lives in Phase 1 implementer work).
    - Storage engines and persistence destinations beyond explicitly named canonical files.
    - Phase 2+ observability pipelines, analytics, tracing, or migration frameworks.
    - Persona / AI behaviour settings (handled outside Phase 1 runtime operational settings).

    Source of truth:
    - These blocks are canonical. Working drafts may exist elsewhere, but contracts must be reflected here.

- id: contracts.allowed_kinds
  kind: meta
  md: |
    Allowed kinds for CONTRACTS:

    - overview
    - meta
    - index
    - reference

- id: contracts.index
  kind: index
  md: |
    ## Contracts Index

    - `contracts.overview`
      Purpose and scope of contracts.

    - `contracts.allowed_kinds`
      Allowed kinds for this file.

    - `contracts.error_envelope_v1`
      Canonical error envelope v1 contract (schema + severity semantics).

    - `contracts.log_record_v1`
      Canonical log record v1 contract (required fields + levels + event taxonomy).

    - `contracts.runtime_logging_wiring_p1`
      Phase 1 wiring rules: where envelopes are created, propagated, and emitted; stop signal is not an envelope.

    - `contracts.work_trace_compat_notes_p1`
      Phase 1 compatibility notes for future work-trace systems (no DB commitment in Phase 1).

    - `contracts.runtime_settings_v1`
      Runtime system settings (“preferences”) contract v1: schema shape, namespacing, types, and compatibility stance.

    - `contracts.runtime_settings_precedence_p1`
      Phase 1 precedence/override semantics for runtime settings (defaults < file < temporary override).

    - `contracts.runtime_settings_persistence_p1`
      Phase 1 persistence boundary for runtime settings (canonical file, read/write expectations, atomicity stance).

    - `contracts.runtime_settings_failure_reporting_p1`
      Phase 1 failure + drift reporting for runtime settings (safe mode, warn-once signals, envelope/log wiring).

    - `contracts.ai_pools_v1`
      AI pool structural contract v1 (pools, entries, ai_ref handles; no runtime behaviour).

    - `contracts.inter_engine_package_v1`
      Canonical inter-engine package v1 (addressing, payload, context bundles, trace breadcrumbs).

    - `contracts.ai_call_package_requirements_v1`
      Phase 2 requirements for `ai_call` packages at the Unified AI API boundary (trace required, targeting rules, provider-stripping stance).

    - `contracts.ai_execution_lanes_v1`
      Phase 2 execution-lane and capability-governance contract defining interactive, batch, and utility lane invariants, including anti-starvation admission control.

- id: contracts.error_envelope_v1
  kind: reference
  md: |
    ## Error Envelope v1

    ### Required fields
    - `envelope_version` (number): MUST be `1`.
    - `id` (string): Unique identifier for correlation.
    - `timestamp` (string): ISO-8601 timestamp when envelope is created.
    - `severity` (string): `WARN | ERROR | FATAL`.
    - `message` (string): Human-readable summary.
    - `origin` (object):
      - `component` (string): e.g., `runtime`
      - `boundary` (string): `start | tick | ingress | stop | shutdown`

    ### Optional fields
    - `kind` (string): Coarse classification.
    - `cause` (object):
      - `type` (string)
      - `message` (string)
      - `stack` (string): Stack trace text (included by default for `WARN/ERROR/FATAL`).
    - `context` (object): Structured metadata (tick number, command, settings source).
    - `tags` (array[string])
    - `is_retryable` (boolean)

    ### Propagation rules
    - Created at runtime catch boundaries via injected `envelope_factory`.
    - Forwarded to logging via injected `envelope_sink`.
    - `RuntimeStopRequested` MUST NOT be wrapped as an envelope.

    ### Extension rule
    - Readers MUST ignore unknown fields.
    - `context` is the primary extension surface in Phase 1.


- id: contracts.log_record_v1
  kind: reference
  md: |
    ## LogRecord v1

    ### Default format
    - JSON Lines (JSONL): one LogRecord JSON object per line.

    ### Required fields
    - `log_version` (number): MUST be `1`.
    - `timestamp` (string): ISO-8601
    - `level` (string): `DEBUG | INFO | WARN | ERROR | FATAL`
    - `event` (string): Stable event name (taxonomy-defined)
    - `component` (string)
    - `message` (string)

    ### Optional fields
    - `tick` (number)
    - `data` (object)
    - `envelope` (object | null)
    - `correlation_id` (string)

    ### Level semantics (Phase 1)
    - `DEBUG`: Development detail; may be suppressed by settings.
    - `INFO`: Normal lifecycle/heartbeat events.
    - `WARN`: Degraded/maybe-bug; MUST be emitted and tracked.
    - `ERROR`: Error event; MUST be emitted; commonly paired with an envelope.
    - `FATAL`: Terminal event; MUST be emitted; paired with an envelope; runtime stops after emission + shutdown attempt.

    ### Minimum event taxonomy (Phase 1 backbone)
    - `runtime.start`
    - `runtime.tick`
    - `runtime.stop_requested`
    - `runtime.shutdown.start`
    - `runtime.shutdown.complete`
    - `ingress.command.received`
    - `config.missing_file`
    - `runtime.envelope`

    ### Heartbeat controls (settings)
    - Heartbeat/tick logging MUST be bounded by settings (`enabled` + `every_n_ticks`) and avoid spam by default.


- id: contracts.runtime_logging_wiring_p1
  kind: reference
  md: |
    ## Phase 1 runtime ↔ logging ↔ envelope wiring rules

    ### Wrap boundaries (envelope creation)
    Envelopes MUST be created at:
    - start boundary
    - tick/step boundary
    - ingress handling boundary
    - shutdown finalization boundary

    ### Non-envelope stop signal
    - Stop requested creates `RuntimeStopRequested`.
    - It MUST be logged as `runtime.stop_requested`.
    - It MUST NOT be wrapped as an envelope.

    ### Propagation
    - Runtime catch boundary → `envelope_factory` → Error Envelope v1.
    - Runtime forwards envelope to `envelope_sink`.
    - Logging emits a LogRecord v1:
      - `event = runtime.envelope`
      - `level` mapped from envelope severity
      - `envelope` populated


- id: contracts.work_trace_compat_notes_p1
  kind: reference
  md: |
    Prefer LogRecord v1 as shared event shape across backbone logs and future work-trace.
    correlation_id remains optional in v1.
    Future systems may add rich correlation inside data without changing v1.

- id: contracts.runtime_settings_v1
  kind: reference
  md: |
    ## Runtime system settings contract (v1)

    Purpose:
    - Define the Phase 1 contract for runtime operational settings (“preferences”).
    - Prevent drift across runtime, logging, and future engines that consume settings.
    - Provide a stable foundation for growth (including large settings sets) without enumerating all keys.

    Canonical file (Phase 1):
    - Path: `lillycore/runtime/config/runtime.system.json`
    - Format: JSON

    Versioning:
    - The file MAY include `schema_version` (number).
    - Phase 1 supported value: `1`.
    - `schema_version` is a decoder selector, not a release counter. It may remain `1` for an extended time.

    Schema shape (preferred / canonical going forward):
    - Top-level object with:
      - `schema_version` (number, SHOULD be `1`)
      - `settings` (object)

    Example (minimal):
    ```json
    {
      "schema_version": 1,
      "settings": {}
    }
    ```

    Legacy compatibility (Phase 1 requirement / blocker):
    - Phase 1 MUST support the current “legacy flat key” file shape (top-level keys without `settings`).
    - If legacy flat keys are detected:
      - runtime MUST emit a **warn-once-per-load** signal (see `contracts.runtime_settings_failure_reporting_p1`).
    - If both legacy flat keys and `settings.*` keys exist, `settings.*` wins (deterministic).

    ## Migration intent (Phase 1 → Phase 2+)
    - The legacy “flat key” settings file shape is supported for Phase 1 compatibility.
    - When the runtime settings file is next edited, the preferred action is to migrate it to the canonical shape:
      - `{ "schema_version": 1, "settings": { ... } }`
    - Migration is intended to be forward-safe:
      - legacy keys may remain temporarily, but `settings.*` is authoritative when both exist.

    Namespacing rules (canonical `settings` object):
    - Keys and namespaces MUST use lowercase `snake_case`.
    - Settings are grouped by namespace to avoid flat-key sprawl.

    Reserved namespaces (Phase 1):
    - `settings.runtime`  (runtime loop operational controls)
    - `settings.helper`  (“potato mode” interaction + scheduling controls)
    - `settings.logging` (operational logging controls; primary consumer is `help_desk_engine`)
    - `settings.config`  (settings-loader policy controls)
    - `settings.engines` (per-engine settings namespaces; keys are engine-owned)

    Reserved engine namespaces (Phase 1; keys may be added later):
    - `settings.engines.drift_engine`
    - `settings.engines.helper_engine`
    - `settings.engines.plugin_engine`
    - `settings.engines.help_desk_engine`
    - `settings.engines.dream_engine`
    - `settings.engines.script_engine`

    Future reserved namespace (ignored in Phase 1):
    - `settings.helper.engine_pool` (reserved for multi-helper-engine scenarios; ignored in Phase 1)

    Supported value types (Phase 1):
    - JSON primitives and containers only:
      - string, boolean, number, object, array, null
    - No tagged/custom/encoded types in Phase 1.

    Unknown keys policy (Phase 1):
    - Unknown keys MUST NOT break load.
    - Unknown keys MUST be ignored.
    - Unknown keys MUST trigger a **warn-once-per-load** signal.

- id: contracts.runtime_settings_precedence_p1
  kind: reference
  md: |
    ## Runtime settings precedence & overrides (Phase 1)

    Precedence (lowest → highest):
    1) Defaults
    2) System settings file (`lillycore/runtime/config/runtime.system.json`)
    3) Temporary override (runtime-provided, in-memory)

    Defaults:
    - Defaults are the baseline for all known settings keys.
    - The settings file MAY be partial; missing keys fall back to defaults.

    Temporary override (Phase 1 contract):
    - Temporary override is provided explicitly by the runtime at startup as an in-memory settings override object.
    - It MUST be applied last.
    - Additional override channels (env vars, CLI flags, remote overrides) are out of scope in Phase 1 unless explicitly added later with precedence rules.

    Canonical-vs-legacy precedence (within the settings file):
    - If `settings` exists, it is the canonical source for keys under `settings.*`.
    - Legacy flat keys are supported for compatibility, but:
      - If both provide a value for the same logical setting, the canonical `settings.*` value wins.

    Merge rule (deterministic):
    - Merge is key-wise and deterministic:
      - defaults → file → temporary override
    - Unknown keys are ignored (with warn-once-per-load reporting per contract).

- id: contracts.runtime_settings_persistence_p1
  kind: reference
  md: |
    ## Runtime settings persistence boundary (Phase 1)

    Boundary:
    - Persistence for Phase 1 runtime settings is limited to the canonical JSON file:
      `lillycore/runtime/config/runtime.system.json`.

    Read behaviour (Phase 1):
    - Settings MUST be loaded at the runtime settings load boundary (startup seam).
    - The loader MUST produce a resolved settings view by applying precedence rules.

    Write behaviour (Phase 1 stance):
    - Phase 1 does not require live mutation of runtime settings during a run.
    - If a write/save operation is implemented in Phase 1, it MUST be explicit (no implicit autosave).

    Atomicity expectation (design-level):
    - If writing is implemented, writes MUST be atomic at the file level (no partial file states).
    - If atomicity cannot be guaranteed, the system MUST treat the file as potentially corrupt on next load and enter safe mode.

    Storage location constraints:
    - The canonical path is fixed by contract.
    - No OS-specific path guessing is permitted beyond the canonical path.

- id: contracts.runtime_settings_failure_reporting_p1
  kind: reference
  md: |
    ## Runtime settings failure reporting (Phase 1)

    Goals:
    - Failures and drift signals must be visible for diagnosis.
    - Settings failures must not brick runtime startup (safe mode stance), unless explicitly escalated later.

    Baseline behaviour:
    - Missing settings file:
      - Runtime MUST fall back to defaults.
      - Runtime SHOULD emit a warning log event: `config.missing_file`.

    Safe mode on invalid/corrupt settings file (Andrew decision):
    - If the file exists but cannot be parsed/validated for Phase 1:
      - Runtime MUST fall back to defaults.
      - Runtime MUST emit:
        - a LogRecord v1 describing the condition, and
        - an Error Envelope v1 created at `origin.boundary: start`.
      - Runtime MUST continue running.

    Warn-once-per-load signals (Phase 1):
    - Legacy flat keys detected:
      - LogRecord v1 event: `config.legacy_keys_detected` (WARN), emitted once per load.
    - Unknown keys detected:
      - LogRecord v1 event: `config.unknown_keys_detected` (WARN), emitted once per load.

    Envelope requirements (when emitted):
    - Envelope MUST follow Error Envelope v1.
    - `origin.component` SHOULD be `runtime`.
    - `origin.boundary` MUST be `start` for settings load failures.
    - Envelope `context` SHOULD include:
      - settings source (`defaults`, `file`, `override`)
      - file path
      - failure classification (missing, invalid, unsupported_version, etc.)
      - whether safe mode was entered

    Logging requirements (when emitted):
    - Logs MUST follow LogRecord v1.
    - `component` SHOULD be `runtime` (even if primary consumer is `help_desk_engine`).
    - If an envelope is emitted, the runtime ↔ logging ↔ envelope wiring rules apply:
      - envelope forwarded to logging (`envelope_sink`)
      - logging emits `runtime.envelope` with mapped severity/level

    Severity guidance (Phase 1):
    - Missing file: WARN log only (`config.missing_file`).
    - Invalid/corrupt file: ERROR log + ERROR envelope; continue (safe mode).
    - Unsupported `schema_version`: ERROR log + ERROR envelope; continue (safe mode).

- id: contracts.ai_pools_v1
  kind: reference
  md: |
    # AI Pools v1 (Phase 1, Structural Only)

    Pools are named structural targets referenced by subsystems.
    Pools may list multiple candidate AI resources as entries.

    ## Non-goals (Phase 1)
    - No execution, scheduling, lifecycle, scaling, idle shutdown, or availability state
    - No runtime counters (error counts) stored in pool definitions
    - No provider APIs or adapter formatting rules

    ## Entity: ai_pool
    - `pool_id` (string, required)
    - `pool_kind` (enum, required): `conversational` | `light` | `worker`
    - `entries` (list[ai_pool_entry], optional)

    ## Entity: ai_pool_entry
    - `entry_id` (string, required)
      - e.g. `primary`, `coder_primary`, `prose_primary`
    - `ai_ref_id` (string, required)
      - opaque handle to the backing AI resource (may be shared across pools initially)
      - future phases may map this to a DB-backed registry
    - `specialties` (list[string], optional)
    - `weaknesses` (list[string], optional)
    - `notes` (string, optional)

- id: contracts.inter_engine_package_v1
  kind: reference
  md: |
    # Inter-Engine Package v1 (Structural Only)

    Canonical container for messages between subsystems (engines, plugins, scripts, AI pools, DB).
    Used for consistent addressing and breadcrumb tracing.

    ## Non-goals
    - No transport, routing rules, retries, timeouts, scheduling, or lifecycle semantics
    - No persistence/storage rules
    - No execution adapter/provider formatting rules

    ## Entity: inter_engine_package

    ### Identity
    - `package_id` (string, required)
    - `package_kind` (string, required)
      Common kinds (non-exhaustive):
      - `user_message`
      - `work_item`
      - `ai_call`
      - `db_call`
      - `user_message_response`
      - `work_item_response`
      - `ai_call_response`
      - `db_call_response`

    ### Addressing
    - `target` (endpoint_ref, required)

    ### Breadcrumb source
    - `source` (endpoint_ref, optional)
      - included when known to support tracing

    ### Payload
    - `payload` (any, optional)
      - may be absent when the payload is carried entirely by `context_bundles`

    ### Context bundles
    - `context_bundles` (list[context_bundle_ref], optional)
      - may be supporting context OR the effective payload

    ### Trace metadata
    - `trace` (trace_meta, optional)

    ### Extensibility
    - `extensions` (map[string, any], optional)
      - receivers must treat unknown fields as inert

    ## Supporting types

    ### endpoint_ref
    Identifies the logical subsystem plus the specific handler when known.
    - `endpoint_kind` (string, required)
      - e.g. `engine`, `plugin`, `script`, `ai_pool`, doc`, `other`
    - `endpoint_id` (string, required)
      - logical name, e.g. `drift_engine`, `helper_engine`, `worker`, `settings_db`
    - `handler_id` (string, optional)
      - REQUIRED when known
      - identifies the specific handler/worker/model/script instance used
      - examples: `coder_primary`, `prose_primary`, `script_apply_patch_v1`, `db_primary`

    ### context_bundle_ref
    - `bundle_id` (string, required)
    - `bundle_kind` (string, optional)

    ### trace_meta
    - `correlation_id` (string, optional)
    - `parent_package_id` (string, optional)
    - `span_id` (string, optional)
    - `tags` (list[string], optional)

- id: contracts.ai_call_package_requirements_v1
  kind: reference
  md: |
    # AI Call Package Requirements v1 (Phase 2 boundary rules)

    Defines Phase 2 requirements for inter-engine packages of kind `ai_call`
    at the Unified AI API boundary.

    This contract layers additional requirements on top of:
    - `contracts.inter_engine_package_v1` (structural container)

    ## Requirements at Unified AI API boundary

    ### Package identity
    - `package_kind` MUST be `ai_call`.

    ### Targeting
    - `target.endpoint_kind` MUST be `ai_pool`.
    - `target.endpoint_id` MUST identify the logical pool target (stable, backend-agnostic).
    - `target.handler_id` SHOULD be present when known (e.g., selected entry or specialization),
      but callers MUST NOT rely on provider/model identifiers.

    ### Trace / provenance (required)
    - `trace` MUST be present.
    - `trace.correlation_id` SHOULD be present when available.
    - The Unified AI API and execution envelope MUST preserve trace metadata for correlation.

    ### Payload and extensibility
    - `payload` MAY be omitted if `context_bundles` carries the effective payload.
    - Unknown fields and `extensions` MUST be treated as inert by receivers (per inter-engine package rules).

    ## Provider-facing stripping rule
    - Provider adapters MUST NOT require `trace` to be embedded into the provider prompt/context.
    - The system MAY strip trace/breadcrumb fields from provider-facing payloads to minimize context load.
    - Trace MUST remain available in envelope/logging surfaces.

    ## Safety posture
    - Execution MUST enforce hard safety limits regardless of runtime settings preferences.
    - Preferences may reduce concurrency or tighten limits, but must not expand beyond safe caps.

- id: contracts.ai_execution_lanes_v1
  kind: reference
  md: |
    # contracts.ai_execution_lanes_v1

    ## Purpose

    This contract defines **Phase 2 execution semantics** for AI work in LillyCORE.

    It establishes:
    - Execution lanes as **resource-governed behavioral categories**
    - Lane-level **invariants** that must hold regardless of implementation
    - A **capability-first request model**
    - A **compatibility bridge** from Phase 1 structural AI pools to Phase 2 lanes

    This contract is **normative**. Downstream Phase 2 design, routing, scheduling, and QA
    work MUST comply with the rules defined here.

    ---

    ## Non-Goals

    This contract does NOT:
    - Define execution code, schedulers, queues, or threading models
    - Define provider adapters or model-specific behavior
    - Define hardware wiring or device allocation strategies
    - Introduce persistence, memory engines, analytics, or Phase 3+ systems

    ---

    ## Execution Lanes

    Execution lanes are **behavioral categories** that govern how AI work competes for
    system resources. Lanes do not imply specific hardware, schedulers, or providers.

    ### Interactive Lane

    **Intent:** Reserved responsiveness for user-facing, latency-sensitive AI work.

    Characteristics:
    - Low-latency expectation
    - Must remain responsive under system load
    - Protected from starvation by other lanes

    ---

    ### Batch Lane

    **Intent:** Long-running or heavy AI work that may be queued or deferred.

    Characteristics:
    - Long-running work permitted
    - Throughput-oriented rather than latency-oriented
    - May be delayed without violating system guarantees

    ---

    ### Utility Lane

    **Intent:** Lightweight, bounded support work for system plumbing and assistance.

    Characteristics:
    - Short-lived, bounded execution
    - Background-friendly
    - Must not materially interfere with interactive responsiveness

    ---

    ## Lane Invariants

    Lane invariants are **hard rules** that must remain true regardless of runtime
    implementation or hardware topology.

    ### Allowed Work

    - **Interactive**
      - Latency-sensitive, user-facing AI interactions
      - Conversational or immediate-response tasks

    - **Batch**
      - Long-running reasoning, planning, extraction, transcription, or analysis tasks

    - **Utility**
      - Routing, classification-ish tasks, embeddings, retrieval helpers, and similar bounded work

    ---

    ### Forbidden Work

    - **Interactive MUST NOT**
      - Execute long-running batch workloads
      - Be used for background or throughput-oriented processing

    - **Utility MUST NOT**
      - Execute unbounded or long-running workloads
      - Starve or block interactive execution

    - **Batch MUST NOT**
      - Consume resources reserved for interactive responsiveness

    ---

    ### Cancellation Expectations

    - All lanes assume **cancellation is supported by default**
    - Non-cancellable work must be explicitly declared by the caller or governing contract
    - Interactive work is expected to respond promptly to cancellation

    ---

    ### Anti-Starvation Posture

    - The interactive lane has **reserved capacity**
    - **Batch admission control invariant:**
      Batch work MUST NOT be admitted (started) if doing so would consume the
      **last interactive-capable slot**

      - This rule is independent of hardware topology (single GPU, multi-GPU, CPU-only)
      - The enforcement mechanism (quotas, tokens, keep-one-free, preemption, etc.)
        is an implementation detail deferred to later Phase 2 work

    - Utility work MUST remain bounded and MUST back off if it threatens interactive responsiveness
    - Starvation prevention is a **hard requirement**, not a best-effort preference

    ---

    ## Capability-First Request Model

    ### Definitions

    - **Capability**
      - A description of what the system can do (e.g., text generation, transcription, embedding)

    - **Lane**
      - A resource-governance category controlling execution behavior

    - **Pool**
      - A structural grouping of AI resources eligible to implement capabilities

    - **Provider / Model**
      - Backend-specific implementations hidden behind adapters

    ---

    ### Core Principle

    > **Capabilities describe intent.**  
    > **Pools, lanes, and providers describe execution.**

    Callers request **capabilities**, not pools, lanes, models, or providers.

    ---

    ### Separation of Concerns

    - Capability requests are backend-agnostic
    - Lane selection governs **how** work may execute, not **what** work is requested
    - Pools and providers implement capabilities within lane constraints

    This separation allows:
    - Backend substitution without API changes
    - Extension to non-LLM capability families (e.g., ASR, retrieval)
    - Stable policy enforcement under hardware scarcity

    ---

    ## Compatibility Bridge (Phase 1 → Phase 2)

    Phase 1 defines **structural AI pool kinds** without execution semantics.
    Phase 2 interprets these pool kinds by default as follows:

    | Phase 1 pool_kind | Phase 2 lane |
    |-------------------|--------------|
    | conversational    | interactive  |
    | worker            | batch        |
    | light             | utility      |

    Notes:
    - This mapping is interpretive and does NOT modify Phase 1 contracts
    - Overrides may exist via configuration defined in later Phase 2 work
    - Overrides MUST NOT violate lane invariants

    ---

    ## Notes / Future (Non-Authoritative)

    - Capability taxonomy expansion (ASR, vision, retrieval) is supported by design
    - Device-level scheduling details are intentionally out of scope
    - Lane override configuration surfaces are deferred to later Phase 2 contracts
